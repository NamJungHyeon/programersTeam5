{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 저장소 구성",
        "description": "프론트엔드(TypeScript, React)와 백엔드(Spring Boot, MySQL) 프로젝트 구조 설정 및 Git 저장소 초기화",
        "details": "1. 프론트엔드 설정:\n   - Create React App with TypeScript 템플릿 사용\n   - 필요한 패키지 설치: axios, styled-components, kakao-maps-sdk\n   - ESLint 및 Prettier 설정\n   - 기본 폴더 구조 생성: components, services, utils, types\n\n2. 백엔드 설정:\n   - Spring Initializr를 사용하여 Spring Boot 프로젝트 생성\n   - 필요한 의존성 추가: Spring Web, Spring Data JPA, MySQL Driver, Lombok\n   - 기본 패키지 구조 생성: controller, service, repository, model, dto\n   - application.properties 기본 설정\n\n3. Git 저장소 설정:\n   - .gitignore 파일 생성 (node_modules, build 폴더, application.properties 등 제외)\n   - README.md 작성 (프로젝트 설명, 설치 방법, 실행 방법 등)\n   - 초기 커밋",
        "testStrategy": "1. 프론트엔드: npm start로 React 앱 실행 확인\n2. 백엔드: Spring Boot 애플리케이션 실행 확인\n3. Git 저장소 정상 작동 확인",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "데이터베이스 스키마 설계 및 구현",
        "description": "대피소 정보를 저장할 MySQL 데이터베이스 스키마 설계 및 JPA 엔티티 구현",
        "details": "1. 데이터베이스 스키마 설계:\n   - shelter 테이블 생성 (대피소 정보 저장)\n     - id: BIGINT (PK, AUTO_INCREMENT)\n     - name: VARCHAR(100) (대피소 이름)\n     - address: VARCHAR(255) (주소)\n     - latitude: DOUBLE (위도)\n     - longitude: DOUBLE (경도)\n     - capacity: INT (수용 인원)\n     - type: VARCHAR(50) (대피소 유형)\n     - contact: VARCHAR(20) (연락처)\n     - created_at: TIMESTAMP\n     - updated_at: TIMESTAMP\n\n2. JPA 엔티티 클래스 구현:\n```java\n@Entity\n@Table(name = \"shelter\")\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class Shelter {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    private String address;\n    private Double latitude;\n    private Double longitude;\n    private Integer capacity;\n    private String type;\n    private String contact;\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    private LocalDateTime updatedAt;\n}\n```\n\n3. Repository 인터페이스 생성:\n```java\npublic interface ShelterRepository extends JpaRepository<Shelter, Long> {\n    List<Shelter> findTop10ByOrderByIdAsc();\n}\n```",
        "testStrategy": "1. MySQL 데이터베이스 연결 테스트\n2. JPA 엔티티 매핑 테스트\n3. 간단한 CRUD 작업 테스트로 Repository 기능 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "카카오 맵 API 연동 및 기본 지도 화면 구현",
        "description": "카카오 맵 API를 React 프로젝트에 연동하고 기본 지도 화면 구현",
        "details": "1. 카카오 맵 API 키 발급:\n   - 카카오 개발자 사이트(https://developers.kakao.com)에서 애플리케이션 등록\n   - JavaScript 키 발급 및 도메인 설정\n\n2. 카카오 맵 SDK 설치 및 설정:\n   - npm install react-kakao-maps-sdk\n   - public/index.html에 스크립트 추가:\n   ```html\n   <script type=\"text/javascript\" src=\"//dapi.kakao.com/v2/maps/sdk.js?appkey=발급받은키&libraries=services\"></script>\n   ```\n\n3. 기본 지도 컴포넌트 구현:\n```tsx\nimport React from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\n\nconst MapComponent: React.FC = () => {\n  // 서울시청 좌표 (초기 중심점)\n  const [center, setCenter] = React.useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3} // 지도 확대 레벨\n      />\n    </div>\n  );\n};\n\nexport default MapComponent;\n```\n\n4. App.tsx에 지도 컴포넌트 추가:\n```tsx\nimport React from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>대피소 찾기 서비스</h1>\n      </header>\n      <main>\n        <MapComponent />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n```",
        "testStrategy": "1. 카카오 맵이 정상적으로 렌더링되는지 확인\n2. 지도 확대/축소 기능 테스트\n3. 지도 이동 기능 테스트\n4. 다양한 브라우저에서 호환성 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "공공데이터 API 연동 및 대피소 데이터 수집",
        "description": "공공데이터 포털에서 대피소 정보를 가져와 데이터베이스에 저장하는 기능 구현",
        "details": "1. 공공데이터 포털 API 키 발급:\n   - 공공데이터 포털(https://www.data.go.kr)에서 회원가입 및 로그인\n   - 민방위 대피시설 API 활용 신청 및 인증키 발급\n\n2. API 호출 서비스 구현:\n```java\n@Service\n@RequiredArgsConstructor\npublic class PublicDataService {\n    private final ShelterRepository shelterRepository;\n    private final RestTemplate restTemplate;\n    \n    private static final String API_URL = \"http://api.data.go.kr/openapi/tn_pubr_public_civil_defense_shelter_api\";\n    private static final String API_KEY = \"발급받은키\";\n    \n    @Scheduled(cron = \"0 0 0 * * ?\") // 매일 자정에 실행\n    public void fetchAndSaveShelterData() {\n        try {\n            String url = API_URL + \"?serviceKey=\" + API_KEY + \"&type=json&numOfRows=1000&pageNo=1\";\n            ResponseEntity<ShelterApiResponse> response = restTemplate.getForEntity(url, ShelterApiResponse.class);\n            \n            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {\n                List<ShelterApiItem> items = response.getBody().getResponse().getBody().getItems();\n                \n                for (ShelterApiItem item : items) {\n                    Shelter shelter = Shelter.builder()\n                        .name(item.getFcltyNm())\n                        .address(item.getRefineRoadnmAddr())\n                        .latitude(Double.parseDouble(item.getRefineWgs84Lat()))\n                        .longitude(Double.parseDouble(item.getRefineWgs84Logt()))\n                        .capacity(Integer.parseInt(item.getFcltyAr()))\n                        .type(item.getShelterDivType())\n                        .contact(item.getMngdptCd())\n                        .build();\n                    \n                    shelterRepository.save(shelter);\n                }\n            }\n        } catch (Exception e) {\n            // 로깅 및 예외 처리\n        }\n    }\n}\n```\n\n3. API 응답 DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\npublic class ShelterApiResponse {\n    private Response response;\n    \n    @Getter @Setter\n    public static class Response {\n        private Header header;\n        private Body body;\n    }\n    \n    @Getter @Setter\n    public static class Header {\n        private String resultCode;\n        private String resultMsg;\n    }\n    \n    @Getter @Setter\n    public static class Body {\n        private List<ShelterApiItem> items;\n        private int numOfRows;\n        private int pageNo;\n        private int totalCount;\n    }\n}\n\n@Getter @Setter\n@NoArgsConstructor\npublic class ShelterApiItem {\n    private String fcltyNm; // 시설명\n    private String refineRoadnmAddr; // 도로명주소\n    private String refineWgs84Lat; // 위도\n    private String refineWgs84Logt; // 경도\n    private String fcltyAr; // 시설면적\n    private String shelterDivType; // 대피소 구분\n    private String mngdptCd; // 관리부서\n}\n```\n\n4. RestTemplate 설정:\n```java\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```",
        "testStrategy": "1. 공공데이터 API 호출 테스트\n2. 응답 데이터 파싱 테스트\n3. 데이터베이스 저장 기능 테스트\n4. 스케줄링 기능 테스트\n5. 예외 처리 테스트",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "주소 검색 UI 컴포넌트 개발",
        "description": "사용자가 주소를 입력하고 검색할 수 있는 UI 컴포넌트 개발 및 자동완성 기능 구현",
        "details": "1. 주소 검색 컴포넌트 구현:\n```tsx\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\n\ninterface SearchProps {\n  onSearch: (address: string) => void;\n}\n\nconst SearchContainer = styled.div`\n  width: 100%;\n  max-width: 500px;\n  margin: 20px auto;\n  position: relative;\n`;\n\nconst SearchInput = styled.input`\n  width: 100%;\n  padding: 12px 15px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  &:focus {\n    outline: none;\n    border-color: #4285f4;\n  }\n`;\n\nconst SearchButton = styled.button`\n  position: absolute;\n  right: 5px;\n  top: 5px;\n  background: #4285f4;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  padding: 8px 15px;\n  cursor: pointer;\n  &:hover {\n    background: #3367d6;\n  }\n`;\n\nconst SuggestionList = styled.ul`\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  width: 100%;\n  background: white;\n  border: 1px solid #ddd;\n  border-top: none;\n  border-radius: 0 0 4px 4px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  z-index: 10;\n`;\n\nconst SuggestionItem = styled.li`\n  padding: 10px 15px;\n  cursor: pointer;\n  &:hover {\n    background: #f5f5f5;\n  }\n`;\n\nconst AddressSearch: React.FC<SearchProps> = ({ onSearch }) => {\n  const [address, setAddress] = useState('');\n  const [suggestions, setSuggestions] = useState<string[]>([]);\n\n  // 카카오 주소 검색 API 사용\n  const searchAddress = (query: string) => {\n    if (!query.trim()) return;\n    \n    // 카카오 주소 검색 API 호출\n    const geocoder = new window.kakao.maps.services.Geocoder();\n    geocoder.addressSearch(query, (result: any[], status: string) => {\n      if (status === window.kakao.maps.services.Status.OK) {\n        const addresses = result.map(item => item.address_name);\n        setSuggestions(addresses);\n      }\n    });\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setAddress(value);\n    if (value.length > 2) {\n      searchAddress(value);\n    } else {\n      setSuggestions([]);\n    }\n  };\n\n  const handleSearch = () => {\n    if (address.trim()) {\n      onSearch(address);\n      setSuggestions([]);\n    }\n  };\n\n  const handleSuggestionClick = (suggestion: string) => {\n    setAddress(suggestion);\n    onSearch(suggestion);\n    setSuggestions([]);\n  };\n\n  return (\n    <SearchContainer>\n      <SearchInput\n        type=\"text\"\n        placeholder=\"주소를 입력하세요\"\n        value={address}\n        onChange={handleInputChange}\n        onKeyPress={(e) => e.key === 'Enter' && handleSearch()}\n      />\n      <SearchButton onClick={handleSearch}>검색</SearchButton>\n      \n      {suggestions.length > 0 && (\n        <SuggestionList>\n          {suggestions.map((suggestion, index) => (\n            <SuggestionItem\n              key={index}\n              onClick={() => handleSuggestionClick(suggestion)}\n            >\n              {suggestion}\n            </SuggestionItem>\n          ))}\n        </SuggestionList>\n      )}\n    </SearchContainer>\n  );\n};\n\nexport default AddressSearch;\n```\n\n2. App.tsx에 주소 검색 컴포넌트 추가:\n```tsx\nimport React, { useState } from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\nimport AddressSearch from './components/AddressSearch';\n\nfunction App() {\n  const [searchAddress, setSearchAddress] = useState('');\n  \n  const handleSearch = (address: string) => {\n    setSearchAddress(address);\n    // 추후 백엔드 API 호출 로직 추가\n  };\n  \n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>대피소 찾기 서비스</h1>\n      </header>\n      <main>\n        <AddressSearch onSearch={handleSearch} />\n        <MapComponent searchAddress={searchAddress} />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n```",
        "testStrategy": "1. 주소 입력 및 검색 기능 테스트\n2. 자동완성 기능 테스트\n3. 엔터 키 및 검색 버튼 동작 테스트\n4. 검색 결과가 상위 컴포넌트로 올바르게 전달되는지 확인\n5. 다양한 주소 형식에 대한 테스트",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "REST API 설계 및 구현",
        "description": "프론트엔드와 통신할 REST API 엔드포인트 설계 및 구현",
        "details": "1. REST API 컨트롤러 구현:\n```java\n@RestController\n@RequestMapping(\"/api/shelters\")\n@RequiredArgsConstructor\npublic class ShelterController {\n    private final ShelterService shelterService;\n    \n    @GetMapping\n    public ResponseEntity<List<ShelterDto>> getAllShelters() {\n        List<ShelterDto> shelters = shelterService.getAllShelters();\n        return ResponseEntity.ok(shelters);\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<ShelterDto> getShelterById(@PathVariable Long id) {\n        return shelterService.getShelterById(id)\n                .map(ResponseEntity::ok)\n                .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @GetMapping(\"/nearest\")\n    public ResponseEntity<List<ShelterDto>> getNearestShelters(\n            @RequestParam Double latitude,\n            @RequestParam Double longitude,\n            @RequestParam(defaultValue = \"10\") int limit) {\n        List<ShelterDto> shelters = shelterService.findNearestShelters(latitude, longitude, limit);\n        return ResponseEntity.ok(shelters);\n    }\n    \n    @GetMapping(\"/search\")\n    public ResponseEntity<List<ShelterDto>> searchSheltersByAddress(@RequestParam String address) {\n        List<ShelterDto> shelters = shelterService.findSheltersByAddress(address);\n        return ResponseEntity.ok(shelters);\n    }\n}\n```\n\n2. 서비스 계층 구현:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ShelterService {\n    private final ShelterRepository shelterRepository;\n    private final AddressService addressService;\n    \n    public List<ShelterDto> getAllShelters() {\n        return shelterRepository.findAll().stream()\n                .map(this::convertToDto)\n                .collect(Collectors.toList());\n    }\n    \n    public Optional<ShelterDto> getShelterById(Long id) {\n        return shelterRepository.findById(id)\n                .map(this::convertToDto);\n    }\n    \n    public List<ShelterDto> findNearestShelters(Double latitude, Double longitude, int limit) {\n        // 모든 대피소를 가져와서 거리 계산 후 정렬\n        List<Shelter> allShelters = shelterRepository.findAll();\n        \n        return allShelters.stream()\n                .map(shelter -> {\n                    ShelterDto dto = convertToDto(shelter);\n                    double distance = calculateDistance(latitude, longitude, \n                                                       shelter.getLatitude(), shelter.getLongitude());\n                    dto.setDistance(distance);\n                    return dto;\n                })\n                .sorted(Comparator.comparing(ShelterDto::getDistance))\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n    \n    public List<ShelterDto> findSheltersByAddress(String address) {\n        // 주소를 좌표로 변환\n        Coordinates coords = addressService.getCoordinatesByAddress(address);\n        if (coords != null) {\n            return findNearestShelters(coords.getLatitude(), coords.getLongitude(), 10);\n        }\n        return Collections.emptyList();\n    }\n    \n    private ShelterDto convertToDto(Shelter shelter) {\n        return ShelterDto.builder()\n                .id(shelter.getId())\n                .name(shelter.getName())\n                .address(shelter.getAddress())\n                .latitude(shelter.getLatitude())\n                .longitude(shelter.getLongitude())\n                .capacity(shelter.getCapacity())\n                .type(shelter.getType())\n                .contact(shelter.getContact())\n                .build();\n    }\n    \n    // 하버사인 공식을 사용한 두 좌표 간 거리 계산 (미터 단위)\n    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        final int R = 6371; // 지구 반경 (km)\n        \n        double latDistance = Math.toRadians(lat2 - lat1);\n        double lonDistance = Math.toRadians(lon2 - lon1);\n        \n        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n        \n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        \n        return R * c * 1000; // 미터 단위로 변환\n    }\n}\n```\n\n3. DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class ShelterDto {\n    private Long id;\n    private String name;\n    private String address;\n    private Double latitude;\n    private Double longitude;\n    private Integer capacity;\n    private String type;\n    private String contact;\n    private Double distance; // 사용자 위치로부터의 거리 (미터)\n}\n\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Coordinates {\n    private Double latitude;\n    private Double longitude;\n}\n```",
        "testStrategy": "1. 각 API 엔드포인트에 대한 단위 테스트 작성\n2. Postman 또는 Swagger를 사용한 API 수동 테스트\n3. 거리 계산 알고리즘 정확성 테스트\n4. 다양한 입력값에 대한 예외 처리 테스트\n5. 응답 시간 및 성능 테스트",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "주소-좌표 변환 서비스 구현",
        "description": "주소를 위도/경도 좌표로 변환하는 서비스 구현",
        "details": "1. 주소 변환 서비스 구현:\n```java\n@Service\npublic class AddressService {\n    private final RestTemplate restTemplate;\n    private final String kakaoApiKey;\n    \n    public AddressService(RestTemplate restTemplate, @Value(\"${kakao.api.key}\") String kakaoApiKey) {\n        this.restTemplate = restTemplate;\n        this.kakaoApiKey = kakaoApiKey;\n    }\n    \n    public Coordinates getCoordinatesByAddress(String address) {\n        try {\n            String url = \"https://dapi.kakao.com/v2/local/search/address.json?query=\" + URLEncoder.encode(address, \"UTF-8\");\n            \n            HttpHeaders headers = new HttpHeaders();\n            headers.set(\"Authorization\", \"KakaoAK \" + kakaoApiKey);\n            \n            HttpEntity<String> entity = new HttpEntity<>(headers);\n            \n            ResponseEntity<KakaoAddressResponse> response = restTemplate.exchange(\n                url, HttpMethod.GET, entity, KakaoAddressResponse.class);\n            \n            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {\n                List<KakaoAddressDocument> documents = response.getBody().getDocuments();\n                if (!documents.isEmpty()) {\n                    KakaoAddressDocument document = documents.get(0);\n                    return new Coordinates(\n                        Double.parseDouble(document.getY()),\n                        Double.parseDouble(document.getX())\n                    );\n                }\n            }\n            return null;\n        } catch (Exception e) {\n            // 로깅 및 예외 처리\n            return null;\n        }\n    }\n}\n```\n\n2. 카카오 API 응답 DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\npublic class KakaoAddressResponse {\n    private List<KakaoAddressDocument> documents;\n}\n\n@Getter @Setter\n@NoArgsConstructor\npublic class KakaoAddressDocument {\n    private String address_name;\n    private String x; // 경도\n    private String y; // 위도\n}\n```\n\n3. application.properties에 카카오 API 키 설정:\n```properties\nkakao.api.key=발급받은키\n```\n\n4. 컨트롤러에 주소 변환 API 추가:\n```java\n@RestController\n@RequestMapping(\"/api/address\")\n@RequiredArgsConstructor\npublic class AddressController {\n    private final AddressService addressService;\n    \n    @GetMapping(\"/coordinates\")\n    public ResponseEntity<Coordinates> getCoordinates(@RequestParam String address) {\n        Coordinates coordinates = addressService.getCoordinatesByAddress(address);\n        if (coordinates != null) {\n            return ResponseEntity.ok(coordinates);\n        }\n        return ResponseEntity.notFound().build();\n    }\n}\n```",
        "testStrategy": "1. 다양한 주소 형식에 대한 변환 테스트\n2. 카카오 API 응답 파싱 테스트\n3. 예외 상황 처리 테스트 (API 호출 실패, 주소 찾기 실패 등)\n4. 응답 시간 측정 테스트\n5. 카카오 API 일일 사용량 제한 고려한 테스트",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "대피소 마커 표시 기능 구현",
        "description": "지도 위에 대피소 위치를 마커로 표시하는 기능 구현",
        "details": "1. 마커 표시 기능이 포함된 지도 컴포넌트 업데이트:\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\nimport axios from 'axios';\n\ninterface Shelter {\n  id: number;\n  name: string;\n  address: string;\n  latitude: number;\n  longitude: number;\n  capacity: number;\n  type: string;\n  contact: string;\n  distance: number;\n}\n\ninterface MapComponentProps {\n  searchAddress: string;\n}\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  const [center, setCenter] = useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  const [shelters, setShelters] = useState<Shelter[]>([]);\n  const [selectedShelter, setSelectedShelter] = useState<Shelter | null>(null);\n  \n  useEffect(() => {\n    if (searchAddress) {\n      // 주소로 대피소 검색\n      axios.get(`/api/shelters/search?address=${encodeURIComponent(searchAddress)}`)\n        .then(response => {\n          setShelters(response.data);\n          \n          if (response.data.length > 0) {\n            // 첫 번째 대피소 위치로 지도 중심 이동\n            setCenter({\n              lat: response.data[0].latitude,\n              lng: response.data[0].longitude\n            });\n          }\n        })\n        .catch(error => {\n          console.error('Error fetching shelters:', error);\n        });\n    }\n  }, [searchAddress]);\n  \n  const handleMarkerClick = (shelter: Shelter) => {\n    setSelectedShelter(shelter);\n  };\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3}\n      >\n        {shelters.map(shelter => (\n          <MapMarker\n            key={shelter.id}\n            position={{ lat: shelter.latitude, lng: shelter.longitude }}\n            onClick={() => handleMarkerClick(shelter)}\n            image={{\n              src: '/marker.png', // 마커 이미지 경로\n              size: { width: 24, height: 35 },\n            }}\n          />\n        ))}\n      </Map>\n      \n      {selectedShelter && (\n        <div className=\"shelter-info\">\n          <h3>{selectedShelter.name}</h3>\n          <p>주소: {selectedShelter.address}</p>\n          <p>수용 인원: {selectedShelter.capacity}명</p>\n          <p>유형: {selectedShelter.type}</p>\n          <p>연락처: {selectedShelter.contact}</p>\n          <p>거리: {(selectedShelter.distance / 1000).toFixed(2)}km</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MapComponent;\n```\n\n2. 마커 이미지 준비:\n   - public 폴더에 marker.png 파일 추가 (대피소 아이콘)\n\n3. 마커 클릭 시 표시할 대피소 정보 스타일 추가 (App.css):\n```css\n.shelter-info {\n  margin-top: 20px;\n  padding: 15px;\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.shelter-info h3 {\n  margin-top: 0;\n  color: #333;\n}\n\n.shelter-info p {\n  margin: 8px 0;\n  color: #555;\n}\n```\n\n4. API 요청을 위한 axios 인스턴스 설정 (src/services/api.ts):\n```typescript\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'http://localhost:8080', // 백엔드 서버 URL\n  timeout: 10000,\n});\n\nexport default api;\n```",
        "testStrategy": "1. 대피소 데이터 로딩 및 마커 표시 테스트\n2. 마커 클릭 이벤트 테스트\n3. 대피소 정보 표시 기능 테스트\n4. 다수의 마커가 있을 때 성능 테스트\n5. 마커 이미지 로딩 테스트",
        "priority": "medium",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "거리 계산 및 정렬 로직 구현",
        "description": "사용자 위치 기준으로 가장 가까운 대피소를 계산하고 정렬하는 로직 구현",
        "details": "1. 거리 계산 알고리즘 최적화:\n```java\n@Service\n@RequiredArgsConstructor\npublic class DistanceCalculationService {\n    private final ShelterRepository shelterRepository;\n    \n    // 지구 반경 (km)\n    private static final double EARTH_RADIUS = 6371;\n    \n    // 특정 좌표 주변의 대피소 검색 (성능 최적화 버전)\n    public List<Shelter> findNearbyShelters(double latitude, double longitude, double radiusInKm) {\n        // 위도 1도 차이 = 약 111km, 경도 1도 차이는 위도에 따라 다름\n        double latDiff = radiusInKm / 111.0;\n        double lonDiff = radiusInKm / (111.0 * Math.cos(Math.toRadians(latitude)));\n        \n        double minLat = latitude - latDiff;\n        double maxLat = latitude + latDiff;\n        double minLon = longitude - lonDiff;\n        double maxLon = longitude + lonDiff;\n        \n        // 대략적인 범위 내 대피소 조회 (DB 쿼리 최적화)\n        List<Shelter> candidateShelters = shelterRepository.findByLatitudeBetweenAndLongitudeBetween(\n                minLat, maxLat, minLon, maxLon);\n        \n        // 정확한 거리 계산 및 필터링\n        return candidateShelters.stream()\n                .filter(shelter -> calculateDistance(latitude, longitude, \n                        shelter.getLatitude(), shelter.getLongitude()) <= radiusInKm * 1000)\n                .collect(Collectors.toList());\n    }\n    \n    // 가장 가까운 N개 대피소 찾기\n    public List<ShelterDto> findNearestShelters(double latitude, double longitude, int limit) {\n        // 먼저 넓은 반경에서 후보 대피소 검색 (예: 10km)\n        List<Shelter> nearbyShelters = findNearbyShelters(latitude, longitude, 10.0);\n        \n        // 거리 계산 및 정렬\n        return nearbyShelters.stream()\n                .map(shelter -> {\n                    double distance = calculateDistance(latitude, longitude, \n                            shelter.getLatitude(), shelter.getLongitude());\n                    \n                    return ShelterDto.builder()\n                            .id(shelter.getId())\n                            .name(shelter.getName())\n                            .address(shelter.getAddress())\n                            .latitude(shelter.getLatitude())\n                            .longitude(shelter.getLongitude())\n                            .capacity(shelter.getCapacity())\n                            .type(shelter.getType())\n                            .contact(shelter.getContact())\n                            .distance(distance)\n                            .build();\n                })\n                .sorted(Comparator.comparing(ShelterDto::getDistance))\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n    \n    // 하버사인 공식을 사용한 두 좌표 간 거리 계산 (미터 단위)\n    public double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        double latDistance = Math.toRadians(lat2 - lat1);\n        double lonDistance = Math.toRadians(lon2 - lon1);\n        \n        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n        \n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        \n        return EARTH_RADIUS * c * 1000; // 미터 단위로 변환\n    }\n}\n```\n\n2. Repository 인터페이스 확장:\n```java\npublic interface ShelterRepository extends JpaRepository<Shelter, Long> {\n    List<Shelter> findByLatitudeBetweenAndLongitudeBetween(\n            double minLatitude, double maxLatitude, \n            double minLongitude, double maxLongitude);\n}\n```\n\n3. 서비스 계층 업데이트:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ShelterService {\n    private final ShelterRepository shelterRepository;\n    private final AddressService addressService;\n    private final DistanceCalculationService distanceService;\n    \n    // 기존 메소드들...\n    \n    public List<ShelterDto> findNearestShelters(Double latitude, Double longitude, int limit) {\n        return distanceService.findNearestShelters(latitude, longitude, limit);\n    }\n    \n    public List<ShelterDto> findSheltersByAddress(String address) {\n        // 주소를 좌표로 변환\n        Coordinates coords = addressService.getCoordinatesByAddress(address);\n        if (coords != null) {\n            return findNearestShelters(coords.getLatitude(), coords.getLongitude(), 10);\n        }\n        return Collections.emptyList();\n    }\n}\n```",
        "testStrategy": "1. 거리 계산 알고리즘 정확성 테스트\n2. 다양한 좌표 쌍에 대한 거리 계산 테스트\n3. 대량의 대피소 데이터에 대한 성능 테스트\n4. 경계 케이스 테스트 (예: 위도/경도 범위 경계)\n5. 정렬 결과 정확성 테스트",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "대피소 상세 정보 표시 기능 구현",
        "description": "선택된 대피소의 상세 정보를 표시하는 UI 컴포넌트 구현",
        "details": "1. 대피소 상세 정보 컴포넌트 구현:\n```tsx\nimport React from 'react';\nimport styled from 'styled-components';\n\ninterface Shelter {\n  id: number;\n  name: string;\n  address: string;\n  latitude: number;\n  longitude: number;\n  capacity: number;\n  type: string;\n  contact: string;\n  distance: number;\n}\n\ninterface ShelterDetailProps {\n  shelter: Shelter | null;\n  onClose: () => void;\n}\n\nconst DetailContainer = styled.div`\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: white;\n  padding: 20px;\n  border-radius: 15px 15px 0 0;\n  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  transform: translateY(${props => props.show ? '0' : '100%'});\n  transition: transform 0.3s ease-in-out;\n  max-height: 50vh;\n  overflow-y: auto;\n`;\n\nconst CloseButton = styled.button`\n  position: absolute;\n  top: 15px;\n  right: 15px;\n  background: none;\n  border: none;\n  font-size: 20px;\n  cursor: pointer;\n  color: #666;\n`;\n\nconst DetailTitle = styled.h2`\n  margin-top: 0;\n  margin-bottom: 15px;\n  color: #333;\n  font-size: 20px;\n`;\n\nconst DetailItem = styled.div`\n  margin-bottom: 10px;\n`;\n\nconst Label = styled.span`\n  font-weight: bold;\n  color: #555;\n  margin-right: 5px;\n`;\n\nconst Value = styled.span`\n  color: #333;\n`;\n\nconst DirectionsButton = styled.button`\n  background: #4285f4;\n  color: white;\n  border: none;\n  padding: 10px 15px;\n  border-radius: 4px;\n  margin-top: 15px;\n  cursor: pointer;\n  font-weight: bold;\n  &:hover {\n    background: #3367d6;\n  }\n`;\n\nconst ShelterDetail: React.FC<ShelterDetailProps> = ({ shelter, onClose }) => {\n  if (!shelter) return null;\n  \n  const openDirections = () => {\n    // 카카오맵 길찾기 URL 생성\n    const url = `https://map.kakao.com/link/to/${shelter.name},${shelter.latitude},${shelter.longitude}`;\n    window.open(url, '_blank');\n  };\n  \n  return (\n    <DetailContainer show={!!shelter}>\n      <CloseButton onClick={onClose}>×</CloseButton>\n      <DetailTitle>{shelter.name}</DetailTitle>\n      \n      <DetailItem>\n        <Label>주소:</Label>\n        <Value>{shelter.address}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>유형:</Label>\n        <Value>{shelter.type}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>수용 인원:</Label>\n        <Value>{shelter.capacity}명</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>연락처:</Label>\n        <Value>{shelter.contact || '정보 없음'}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>거리:</Label>\n        <Value>{(shelter.distance / 1000).toFixed(2)}km</Value>\n      </DetailItem>\n      \n      <DirectionsButton onClick={openDirections}>\n        길찾기\n      </DirectionsButton>\n    </DetailContainer>\n  );\n};\n\nexport default ShelterDetail;\n```\n\n2. MapComponent 업데이트하여 상세 정보 컴포넌트 통합:\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\nimport axios from 'axios';\nimport ShelterDetail from './ShelterDetail';\nimport api from '../services/api';\n\n// 인터페이스 정의 생략 (이전과 동일)\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  const [center, setCenter] = useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  const [shelters, setShelters] = useState<Shelter[]>([]);\n  const [selectedShelter, setSelectedShelter] = useState<Shelter | null>(null);\n  \n  useEffect(() => {\n    if (searchAddress) {\n      // 주소로 대피소 검색\n      api.get(`/api/shelters/search?address=${encodeURIComponent(searchAddress)}`)\n        .then(response => {\n          setShelters(response.data);\n          \n          if (response.data.length > 0) {\n            // 첫 번째 대피소 위치로 지도 중심 이동\n            setCenter({\n              lat: response.data[0].latitude,\n              lng: response.data[0].longitude\n            });\n          }\n        })\n        .catch(error => {\n          console.error('Error fetching shelters:', error);\n        });\n    }\n  }, [searchAddress]);\n  \n  const handleMarkerClick = (shelter: Shelter) => {\n    setSelectedShelter(shelter);\n  };\n  \n  const handleCloseDetail = () => {\n    setSelectedShelter(null);\n  };\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3}\n      >\n        {shelters.map(shelter => (\n          <MapMarker\n            key={shelter.id}\n            position={{ lat: shelter.latitude, lng: shelter.longitude }}\n            onClick={() => handleMarkerClick(shelter)}\n            image={{\n              src: '/marker.png',\n              size: { width: 24, height: 35 },\n            }}\n          />\n        ))}\n      </Map>\n      \n      <ShelterDetail \n        shelter={selectedShelter} \n        onClose={handleCloseDetail} \n      />\n    </div>\n  );\n};\n\nexport default MapComponent;\n```",
        "testStrategy": "1. 대피소 상세 정보 표시 기능 테스트\n2. 모달 열기/닫기 기능 테스트\n3. 길찾기 버튼 기능 테스트\n4. 다양한 화면 크기에서의 UI 테스트\n5. 누락된 정보 처리 테스트 (예: 연락처 없음)",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "반응형 디자인 적용",
        "description": "모바일 및 데스크톱 환경에 모두 대응하는 반응형 UI 구현",
        "details": "1. 반응형 스타일 컴포넌트 설정:\n```tsx\n// src/styles/responsive.ts\nimport { css } from 'styled-components';\n\nexport const breakpoints = {\n  mobile: 576,\n  tablet: 768,\n  desktop: 992,\n};\n\nexport const media = {\n  mobile: (...args) => css`\n    @media (max-width: ${breakpoints.mobile}px) {\n      ${css(...args)};\n    }\n  `,\n  tablet: (...args) => css`\n    @media (min-width: ${breakpoints.mobile + 1}px) and (max-width: ${breakpoints.tablet}px) {\n      ${css(...args)};\n    }\n  `,\n  desktop: (...args) => css`\n    @media (min-width: ${breakpoints.tablet + 1}px) {\n      ${css(...args)};\n    }\n  `,\n};\n```\n\n2. 반응형 레이아웃 컴포넌트 구현:\n```tsx\n// src/components/Layout.tsx\nimport React from 'react';\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\nconst Container = styled.div`\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 20px;\n  \n  ${media.mobile`\n    padding: 0 10px;\n  `}\n`;\n\nconst Header = styled.header`\n  padding: 20px 0;\n  text-align: center;\n  \n  ${media.mobile`\n    padding: 15px 0;\n  `}\n`;\n\nconst Title = styled.h1`\n  font-size: 28px;\n  color: #333;\n  margin: 0;\n  \n  ${media.mobile`\n    font-size: 22px;\n  `}\n`;\n\nconst Main = styled.main`\n  min-height: calc(100vh - 120px);\n`;\n\nconst Footer = styled.footer`\n  padding: 20px 0;\n  text-align: center;\n  color: #666;\n  font-size: 14px;\n  \n  ${media.mobile`\n    padding: 15px 0;\n    font-size: 12px;\n  `}\n`;\n\ninterface LayoutProps {\n  children: React.ReactNode;\n}\n\nconst Layout: React.FC<LayoutProps> = ({ children }) => {\n  return (\n    <Container>\n      <Header>\n        <Title>대피소 찾기 서비스</Title>\n      </Header>\n      <Main>{children}</Main>\n      <Footer>\n        &copy; {new Date().getFullYear()} SafetyFirst. All rights reserved.\n      </Footer>\n    </Container>\n  );\n};\n\nexport default Layout;\n```\n\n3. 반응형 지도 컴포넌트 업데이트:\n```tsx\n// MapComponent.tsx 업데이트\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\n// 기존 코드...\n\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 600px;\n  margin-bottom: 20px;\n  \n  ${media.mobile`\n    height: 400px;\n    margin-bottom: 10px;\n  `}\n`;\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  // 기존 코드...\n  \n  return (\n    <MapContainer>\n      <Map\n        center={center}\n        style={{ width: '100%', height: '100%' }}\n        level={3}\n      >\n        {/* 마커 코드... */}\n      </Map>\n      \n      <ShelterDetail \n        shelter={selectedShelter} \n        onClose={handleCloseDetail} \n      />\n    </MapContainer>\n  );\n};\n```\n\n4. 반응형 검색 컴포넌트 업데이트:\n```tsx\n// AddressSearch.tsx 업데이트\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\n// 기존 코드...\n\nconst SearchContainer = styled.div`\n  width: 100%;\n  max-width: 500px;\n  margin: 20px auto;\n  position: relative;\n  \n  ${media.mobile`\n    max-width: 100%;\n    margin: 10px auto;\n  `}\n`;\n\nconst SearchInput = styled.input`\n  width: 100%;\n  padding: 12px 15px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  \n  ${media.mobile`\n    padding: 10px;\n    font-size: 14px;\n  `}\n  \n  &:focus {\n    outline: none;\n    border-color: #4285f4;\n  }\n`;\n\n// 나머지 코드...\n```\n\n5. App.tsx에 레이아웃 적용:\n```tsx\nimport React, { useState } from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\nimport AddressSearch from './components/AddressSearch';\nimport Layout from './components/Layout';\n\nfunction App() {\n  const [searchAddress, setSearchAddress] = useState('');\n  \n  const handleSearch = (address: string) => {\n    setSearchAddress(address);\n  };\n  \n  return (\n    <Layout>\n      <AddressSearch onSearch={handleSearch} />\n      <MapComponent searchAddress={searchAddress} />\n    </Layout>\n  );\n}\n\nexport default App;\n```\n\n6. 글로벌 스타일 추가 (src/styles/GlobalStyle.ts):\n```tsx\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    box-sizing: border-box;\n  }\n  \n  body {\n    margin: 0;\n    padding: 0;\n    font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    background-color: #f9f9f9;\n  }\n`;\n\nexport default GlobalStyle;\n```\n\n7. index.tsx에 글로벌 스타일 적용:\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport GlobalStyle from './styles/GlobalStyle';\n\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```",
        "testStrategy": "1. 다양한 화면 크기에서의 레이아웃 테스트 (모바일, 태블릿, 데스크톱)\n2. 브라우저 호환성 테스트 (Chrome, Firefox, Safari, Edge)\n3. 반응형 요소들의 동작 확인\n4. 모바일 터치 인터랙션 테스트\n5. 다양한 기기에서의 사용성 테스트",
        "priority": "low",
        "dependencies": [
          5,
          8,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "코드 최적화 및 문서화",
        "description": "코드 리팩토링, 주석 추가, 문서화 및 최종 테스트",
        "details": "1. 코드 리팩토링:\n   - 중복 코드 제거\n   - 컴포넌트 분리 및 재사용성 향상\n   - 성능 최적화 (불필요한 렌더링 방지)\n   - 타입 정의 개선\n\n2. 주석 추가:\n   - 각 컴포넌트 및 함수에 JSDoc 형식의 주석 추가\n   - 복잡한 로직에 대한 설명 추가\n   - 예시:\n   ```typescript\n   /**\n    * 두 지리적 좌표 사이의 거리를 계산합니다.\n    * @param lat1 - 첫 번째 위치의 위도\n    * @param lon1 - 첫 번째 위치의 경도\n    * @param lat2 - 두 번째 위치의 위도\n    * @param lon2 - 두 번째 위치의 경도\n    * @returns 두 위치 사이의 거리 (미터 단위)\n    */\n   function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n     // 구현...\n   }\n   ```\n\n3. 에러 처리 개선:\n   - 사용자 친화적인 에러 메시지 표시\n   - 에러 발생 시 대체 UI 제공\n   - 예시:\n   ```typescript\n   const ErrorMessage = styled.div`\n     color: #d32f2f;\n     background-color: #ffebee;\n     padding: 10px;\n     border-radius: 4px;\n     margin: 10px 0;\n     text-align: center;\n   `;\n   \n   // 컴포넌트 내부\n   const [error, setError] = useState<string | null>(null);\n   \n   // API 호출 부분\n   api.get('/api/shelters/search')\n     .then(response => {\n       // 성공 처리\n     })\n     .catch(err => {\n       console.error('API 호출 실패:', err);\n       setError('대피소 정보를 불러오는데 실패했습니다. 잠시 후 다시 시도해주세요.');\n     });\n   \n   // 렌더링 부분\n   {error && <ErrorMessage>{error}</ErrorMessage>}\n   ```\n\n4. 로딩 상태 처리:\n   - 데이터 로딩 중 스켈레톤 UI 또는 로딩 인디케이터 표시\n   - 예시:\n   ```typescript\n   const LoadingSpinner = styled.div`\n     display: flex;\n     justify-content: center;\n     align-items: center;\n     height: 200px;\n   `;\n   \n   // 컴포넌트 내부\n   const [loading, setLoading] = useState(false);\n   \n   // API 호출 부분\n   setLoading(true);\n   api.get('/api/shelters/search')\n     .then(response => {\n       // 성공 처리\n     })\n     .catch(err => {\n       // 에러 처리\n     })\n     .finally(() => {\n       setLoading(false);\n     });\n   \n   // 렌더링 부분\n   {loading ? (\n     <LoadingSpinner>\n       <div className=\"spinner\"></div>\n     </LoadingSpinner>\n   ) : (\n     // 실제 컨텐츠\n   )}\n   ```\n\n5. README.md 작성:\n   - 프로젝트 개요\n   - 설치 방법\n   - 실행 방법\n   - API 문서\n   - 폴더 구조 설명\n   - 기술 스택 소개\n   - 기여 방법\n\n6. API 문서화:\n   - Swagger 또는 Spring REST Docs를 사용한 API 문서화\n   - 예시 (Swagger 설정):\n   ```java\n   @Configuration\n   @EnableSwagger2\n   public class SwaggerConfig {\n       @Bean\n       public Docket api() {\n           return new Docket(DocumentationType.SWAGGER_2)\n                   .select()\n                   .apis(RequestHandlerSelectors.basePackage(\"com.safetyfirst.controller\"))\n                   .paths(PathSelectors.any())\n                   .build()\n                   .apiInfo(apiInfo());\n       }\n       \n       private ApiInfo apiInfo() {\n           return new ApiInfoBuilder()\n                   .title(\"SafetyFirst API\")\n                   .description(\"대피소 찾기 서비스 API 문서\")\n                   .version(\"1.0.0\")\n                   .build();\n       }\n   }\n   ```\n\n7. 최종 테스트:\n   - 모든 기능에 대한 종합 테스트\n   - 크로스 브라우저 테스트\n   - 성능 테스트\n   - 사용성 테스트",
        "testStrategy": "1. 코드 품질 검사 도구 실행 (ESLint, SonarQube 등)\n2. 단위 테스트 및 통합 테스트 실행\n3. 성능 테스트 (로딩 시간, 메모리 사용량 등)\n4. 크로스 브라우저 테스트\n5. 코드 리뷰 진행\n6. 문서 정확성 검증",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-01T07:52:13.129Z",
      "updated": "2025-07-01T07:52:13.129Z",
      "description": "Tasks for master context"
    }
  },
  "backend-dev": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 저장소 구성",
        "description": "프론트엔드(TypeScript, React)와 백엔드(Spring Boot, MySQL) 프로젝트 구조 설정 및 Git 저장소 초기화",
        "details": "1. 프론트엔드 설정:\n   - Create React App with TypeScript 템플릿 사용\n   - 필요한 패키지 설치: axios, styled-components, kakao-maps-sdk\n   - ESLint 및 Prettier 설정\n   - 기본 폴더 구조 생성: components, services, utils, types\n\n2. 백엔드 설정:\n   - Spring Initializr를 사용하여 Spring Boot 프로젝트 생성\n   - 필요한 의존성 추가: Spring Web, Spring Data JPA, MySQL Driver, Lombok\n   - 기본 패키지 구조 생성: controller, service, repository, model, dto\n   - application.properties 기본 설정\n\n3. Git 저장소 설정:\n   - .gitignore 파일 생성 (node_modules, build 폴더, application.properties 등 제외)\n   - README.md 작성 (프로젝트 설명, 설치 방법, 실행 방법 등)\n   - 초기 커밋",
        "testStrategy": "1. 프론트엔드: npm start로 React 앱 실행 확인\n2. 백엔드: Spring Boot 애플리케이션 실행 확인\n3. Git 저장소 정상 작동 확인",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "데이터베이스 스키마 설계 및 구현",
        "description": "대피소 정보를 저장할 MySQL 데이터베이스 스키마 설계 및 JPA 엔티티 구현",
        "details": "1. 데이터베이스 스키마 설계:\n   - shelter 테이블 생성 (대피소 정보 저장)\n     - id: BIGINT (PK, AUTO_INCREMENT)\n     - name: VARCHAR(100) (대피소 이름)\n     - address: VARCHAR(255) (주소)\n     - latitude: DOUBLE (위도)\n     - longitude: DOUBLE (경도)\n     - capacity: INT (수용 인원)\n     - type: VARCHAR(50) (대피소 유형)\n     - contact: VARCHAR(20) (연락처)\n     - created_at: TIMESTAMP\n     - updated_at: TIMESTAMP\n\n2. JPA 엔티티 클래스 구현:\n```java\n@Entity\n@Table(name = \"shelter\")\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class Shelter {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    private String address;\n    private Double latitude;\n    private Double longitude;\n    private Integer capacity;\n    private String type;\n    private String contact;\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    private LocalDateTime updatedAt;\n}\n```\n\n3. Repository 인터페이스 생성:\n```java\npublic interface ShelterRepository extends JpaRepository<Shelter, Long> {\n    List<Shelter> findTop10ByOrderByIdAsc();\n}\n```",
        "testStrategy": "1. MySQL 데이터베이스 연결 테스트\n2. JPA 엔티티 매핑 테스트\n3. 간단한 CRUD 작업 테스트로 Repository 기능 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "카카오 맵 API 연동 및 기본 지도 화면 구현",
        "description": "카카오 맵 API를 React 프로젝트에 연동하고 기본 지도 화면 구현",
        "details": "1. 카카오 맵 API 키 발급:\n   - 카카오 개발자 사이트(https://developers.kakao.com)에서 애플리케이션 등록\n   - JavaScript 키 발급 및 도메인 설정\n\n2. 카카오 맵 SDK 설치 및 설정:\n   - npm install react-kakao-maps-sdk\n   - public/index.html에 스크립트 추가:\n   ```html\n   <script type=\"text/javascript\" src=\"//dapi.kakao.com/v2/maps/sdk.js?appkey=발급받은키&libraries=services\"></script>\n   ```\n\n3. 기본 지도 컴포넌트 구현:\n```tsx\nimport React from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\n\nconst MapComponent: React.FC = () => {\n  // 서울시청 좌표 (초기 중심점)\n  const [center, setCenter] = React.useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3} // 지도 확대 레벨\n      />\n    </div>\n  );\n};\n\nexport default MapComponent;\n```\n\n4. App.tsx에 지도 컴포넌트 추가:\n```tsx\nimport React from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>대피소 찾기 서비스</h1>\n      </header>\n      <main>\n        <MapComponent />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n```",
        "testStrategy": "1. 카카오 맵이 정상적으로 렌더링되는지 확인\n2. 지도 확대/축소 기능 테스트\n3. 지도 이동 기능 테스트\n4. 다양한 브라우저에서 호환성 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "공공데이터 API 연동 및 대피소 데이터 수집",
        "description": "공공데이터 포털에서 대피소 정보를 가져와 데이터베이스에 저장하는 기능 구현",
        "details": "1. 공공데이터 포털 API 키 발급:\n   - 공공데이터 포털(https://www.data.go.kr)에서 회원가입 및 로그인\n   - 민방위 대피시설 API 활용 신청 및 인증키 발급\n\n2. API 호출 서비스 구현:\n```java\n@Service\n@RequiredArgsConstructor\npublic class PublicDataService {\n    private final ShelterRepository shelterRepository;\n    private final RestTemplate restTemplate;\n    \n    private static final String API_URL = \"http://api.data.go.kr/openapi/tn_pubr_public_civil_defense_shelter_api\";\n    private static final String API_KEY = \"발급받은키\";\n    \n    @Scheduled(cron = \"0 0 0 * * ?\") // 매일 자정에 실행\n    public void fetchAndSaveShelterData() {\n        try {\n            String url = API_URL + \"?serviceKey=\" + API_KEY + \"&type=json&numOfRows=1000&pageNo=1\";\n            ResponseEntity<ShelterApiResponse> response = restTemplate.getForEntity(url, ShelterApiResponse.class);\n            \n            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {\n                List<ShelterApiItem> items = response.getBody().getResponse().getBody().getItems();\n                \n                for (ShelterApiItem item : items) {\n                    Shelter shelter = Shelter.builder()\n                        .name(item.getFcltyNm())\n                        .address(item.getRefineRoadnmAddr())\n                        .latitude(Double.parseDouble(item.getRefineWgs84Lat()))\n                        .longitude(Double.parseDouble(item.getRefineWgs84Logt()))\n                        .capacity(Integer.parseInt(item.getFcltyAr()))\n                        .type(item.getShelterDivType())\n                        .contact(item.getMngdptCd())\n                        .build();\n                    \n                    shelterRepository.save(shelter);\n                }\n            }\n        } catch (Exception e) {\n            // 로깅 및 예외 처리\n        }\n    }\n}\n```\n\n3. API 응답 DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\npublic class ShelterApiResponse {\n    private Response response;\n    \n    @Getter @Setter\n    public static class Response {\n        private Header header;\n        private Body body;\n    }\n    \n    @Getter @Setter\n    public static class Header {\n        private String resultCode;\n        private String resultMsg;\n    }\n    \n    @Getter @Setter\n    public static class Body {\n        private List<ShelterApiItem> items;\n        private int numOfRows;\n        private int pageNo;\n        private int totalCount;\n    }\n}\n\n@Getter @Setter\n@NoArgsConstructor\npublic class ShelterApiItem {\n    private String fcltyNm; // 시설명\n    private String refineRoadnmAddr; // 도로명주소\n    private String refineWgs84Lat; // 위도\n    private String refineWgs84Logt; // 경도\n    private String fcltyAr; // 시설면적\n    private String shelterDivType; // 대피소 구분\n    private String mngdptCd; // 관리부서\n}\n```\n\n4. RestTemplate 설정:\n```java\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```",
        "testStrategy": "1. 공공데이터 API 호출 테스트\n2. 응답 데이터 파싱 테스트\n3. 데이터베이스 저장 기능 테스트\n4. 스케줄링 기능 테스트\n5. 예외 처리 테스트",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "주소 검색 UI 컴포넌트 개발",
        "description": "사용자가 주소를 입력하고 검색할 수 있는 UI 컴포넌트 개발 및 자동완성 기능 구현",
        "details": "1. 주소 검색 컴포넌트 구현:\n```tsx\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\n\ninterface SearchProps {\n  onSearch: (address: string) => void;\n}\n\nconst SearchContainer = styled.div`\n  width: 100%;\n  max-width: 500px;\n  margin: 20px auto;\n  position: relative;\n`;\n\nconst SearchInput = styled.input`\n  width: 100%;\n  padding: 12px 15px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  &:focus {\n    outline: none;\n    border-color: #4285f4;\n  }\n`;\n\nconst SearchButton = styled.button`\n  position: absolute;\n  right: 5px;\n  top: 5px;\n  background: #4285f4;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  padding: 8px 15px;\n  cursor: pointer;\n  &:hover {\n    background: #3367d6;\n  }\n`;\n\nconst SuggestionList = styled.ul`\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  width: 100%;\n  background: white;\n  border: 1px solid #ddd;\n  border-top: none;\n  border-radius: 0 0 4px 4px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  z-index: 10;\n`;\n\nconst SuggestionItem = styled.li`\n  padding: 10px 15px;\n  cursor: pointer;\n  &:hover {\n    background: #f5f5f5;\n  }\n`;\n\nconst AddressSearch: React.FC<SearchProps> = ({ onSearch }) => {\n  const [address, setAddress] = useState('');\n  const [suggestions, setSuggestions] = useState<string[]>([]);\n\n  // 카카오 주소 검색 API 사용\n  const searchAddress = (query: string) => {\n    if (!query.trim()) return;\n    \n    // 카카오 주소 검색 API 호출\n    const geocoder = new window.kakao.maps.services.Geocoder();\n    geocoder.addressSearch(query, (result: any[], status: string) => {\n      if (status === window.kakao.maps.services.Status.OK) {\n        const addresses = result.map(item => item.address_name);\n        setSuggestions(addresses);\n      }\n    });\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setAddress(value);\n    if (value.length > 2) {\n      searchAddress(value);\n    } else {\n      setSuggestions([]);\n    }\n  };\n\n  const handleSearch = () => {\n    if (address.trim()) {\n      onSearch(address);\n      setSuggestions([]);\n    }\n  };\n\n  const handleSuggestionClick = (suggestion: string) => {\n    setAddress(suggestion);\n    onSearch(suggestion);\n    setSuggestions([]);\n  };\n\n  return (\n    <SearchContainer>\n      <SearchInput\n        type=\"text\"\n        placeholder=\"주소를 입력하세요\"\n        value={address}\n        onChange={handleInputChange}\n        onKeyPress={(e) => e.key === 'Enter' && handleSearch()}\n      />\n      <SearchButton onClick={handleSearch}>검색</SearchButton>\n      \n      {suggestions.length > 0 && (\n        <SuggestionList>\n          {suggestions.map((suggestion, index) => (\n            <SuggestionItem\n              key={index}\n              onClick={() => handleSuggestionClick(suggestion)}\n            >\n              {suggestion}\n            </SuggestionItem>\n          ))}\n        </SuggestionList>\n      )}\n    </SearchContainer>\n  );\n};\n\nexport default AddressSearch;\n```\n\n2. App.tsx에 주소 검색 컴포넌트 추가:\n```tsx\nimport React, { useState } from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\nimport AddressSearch from './components/AddressSearch';\n\nfunction App() {\n  const [searchAddress, setSearchAddress] = useState('');\n  \n  const handleSearch = (address: string) => {\n    setSearchAddress(address);\n    // 추후 백엔드 API 호출 로직 추가\n  };\n  \n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>대피소 찾기 서비스</h1>\n      </header>\n      <main>\n        <AddressSearch onSearch={handleSearch} />\n        <MapComponent searchAddress={searchAddress} />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n```",
        "testStrategy": "1. 주소 입력 및 검색 기능 테스트\n2. 자동완성 기능 테스트\n3. 엔터 키 및 검색 버튼 동작 테스트\n4. 검색 결과가 상위 컴포넌트로 올바르게 전달되는지 확인\n5. 다양한 주소 형식에 대한 테스트",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "REST API 설계 및 구현",
        "description": "프론트엔드와 통신할 REST API 엔드포인트 설계 및 구현",
        "details": "1. REST API 컨트롤러 구현:\n```java\n@RestController\n@RequestMapping(\"/api/shelters\")\n@RequiredArgsConstructor\npublic class ShelterController {\n    private final ShelterService shelterService;\n    \n    @GetMapping\n    public ResponseEntity<List<ShelterDto>> getAllShelters() {\n        List<ShelterDto> shelters = shelterService.getAllShelters();\n        return ResponseEntity.ok(shelters);\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<ShelterDto> getShelterById(@PathVariable Long id) {\n        return shelterService.getShelterById(id)\n                .map(ResponseEntity::ok)\n                .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @GetMapping(\"/nearest\")\n    public ResponseEntity<List<ShelterDto>> getNearestShelters(\n            @RequestParam Double latitude,\n            @RequestParam Double longitude,\n            @RequestParam(defaultValue = \"10\") int limit) {\n        List<ShelterDto> shelters = shelterService.findNearestShelters(latitude, longitude, limit);\n        return ResponseEntity.ok(shelters);\n    }\n    \n    @GetMapping(\"/search\")\n    public ResponseEntity<List<ShelterDto>> searchSheltersByAddress(@RequestParam String address) {\n        List<ShelterDto> shelters = shelterService.findSheltersByAddress(address);\n        return ResponseEntity.ok(shelters);\n    }\n}\n```\n\n2. 서비스 계층 구현:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ShelterService {\n    private final ShelterRepository shelterRepository;\n    private final AddressService addressService;\n    \n    public List<ShelterDto> getAllShelters() {\n        return shelterRepository.findAll().stream()\n                .map(this::convertToDto)\n                .collect(Collectors.toList());\n    }\n    \n    public Optional<ShelterDto> getShelterById(Long id) {\n        return shelterRepository.findById(id)\n                .map(this::convertToDto);\n    }\n    \n    public List<ShelterDto> findNearestShelters(Double latitude, Double longitude, int limit) {\n        // 모든 대피소를 가져와서 거리 계산 후 정렬\n        List<Shelter> allShelters = shelterRepository.findAll();\n        \n        return allShelters.stream()\n                .map(shelter -> {\n                    ShelterDto dto = convertToDto(shelter);\n                    double distance = calculateDistance(latitude, longitude, \n                                                       shelter.getLatitude(), shelter.getLongitude());\n                    dto.setDistance(distance);\n                    return dto;\n                })\n                .sorted(Comparator.comparing(ShelterDto::getDistance))\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n    \n    public List<ShelterDto> findSheltersByAddress(String address) {\n        // 주소를 좌표로 변환\n        Coordinates coords = addressService.getCoordinatesByAddress(address);\n        if (coords != null) {\n            return findNearestShelters(coords.getLatitude(), coords.getLongitude(), 10);\n        }\n        return Collections.emptyList();\n    }\n    \n    private ShelterDto convertToDto(Shelter shelter) {\n        return ShelterDto.builder()\n                .id(shelter.getId())\n                .name(shelter.getName())\n                .address(shelter.getAddress())\n                .latitude(shelter.getLatitude())\n                .longitude(shelter.getLongitude())\n                .capacity(shelter.getCapacity())\n                .type(shelter.getType())\n                .contact(shelter.getContact())\n                .build();\n    }\n    \n    // 하버사인 공식을 사용한 두 좌표 간 거리 계산 (미터 단위)\n    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        final int R = 6371; // 지구 반경 (km)\n        \n        double latDistance = Math.toRadians(lat2 - lat1);\n        double lonDistance = Math.toRadians(lon2 - lon1);\n        \n        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n        \n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        \n        return R * c * 1000; // 미터 단위로 변환\n    }\n}\n```\n\n3. DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class ShelterDto {\n    private Long id;\n    private String name;\n    private String address;\n    private Double latitude;\n    private Double longitude;\n    private Integer capacity;\n    private String type;\n    private String contact;\n    private Double distance; // 사용자 위치로부터의 거리 (미터)\n}\n\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Coordinates {\n    private Double latitude;\n    private Double longitude;\n}\n```",
        "testStrategy": "1. 각 API 엔드포인트에 대한 단위 테스트 작성\n2. Postman 또는 Swagger를 사용한 API 수동 테스트\n3. 거리 계산 알고리즘 정확성 테스트\n4. 다양한 입력값에 대한 예외 처리 테스트\n5. 응답 시간 및 성능 테스트",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "주소-좌표 변환 서비스 구현",
        "description": "주소를 위도/경도 좌표로 변환하는 서비스 구현",
        "details": "1. 주소 변환 서비스 구현:\n```java\n@Service\npublic class AddressService {\n    private final RestTemplate restTemplate;\n    private final String kakaoApiKey;\n    \n    public AddressService(RestTemplate restTemplate, @Value(\"${kakao.api.key}\") String kakaoApiKey) {\n        this.restTemplate = restTemplate;\n        this.kakaoApiKey = kakaoApiKey;\n    }\n    \n    public Coordinates getCoordinatesByAddress(String address) {\n        try {\n            String url = \"https://dapi.kakao.com/v2/local/search/address.json?query=\" + URLEncoder.encode(address, \"UTF-8\");\n            \n            HttpHeaders headers = new HttpHeaders();\n            headers.set(\"Authorization\", \"KakaoAK \" + kakaoApiKey);\n            \n            HttpEntity<String> entity = new HttpEntity<>(headers);\n            \n            ResponseEntity<KakaoAddressResponse> response = restTemplate.exchange(\n                url, HttpMethod.GET, entity, KakaoAddressResponse.class);\n            \n            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {\n                List<KakaoAddressDocument> documents = response.getBody().getDocuments();\n                if (!documents.isEmpty()) {\n                    KakaoAddressDocument document = documents.get(0);\n                    return new Coordinates(\n                        Double.parseDouble(document.getY()),\n                        Double.parseDouble(document.getX())\n                    );\n                }\n            }\n            return null;\n        } catch (Exception e) {\n            // 로깅 및 예외 처리\n            return null;\n        }\n    }\n}\n```\n\n2. 카카오 API 응답 DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\npublic class KakaoAddressResponse {\n    private List<KakaoAddressDocument> documents;\n}\n\n@Getter @Setter\n@NoArgsConstructor\npublic class KakaoAddressDocument {\n    private String address_name;\n    private String x; // 경도\n    private String y; // 위도\n}\n```\n\n3. application.properties에 카카오 API 키 설정:\n```properties\nkakao.api.key=발급받은키\n```\n\n4. 컨트롤러에 주소 변환 API 추가:\n```java\n@RestController\n@RequestMapping(\"/api/address\")\n@RequiredArgsConstructor\npublic class AddressController {\n    private final AddressService addressService;\n    \n    @GetMapping(\"/coordinates\")\n    public ResponseEntity<Coordinates> getCoordinates(@RequestParam String address) {\n        Coordinates coordinates = addressService.getCoordinatesByAddress(address);\n        if (coordinates != null) {\n            return ResponseEntity.ok(coordinates);\n        }\n        return ResponseEntity.notFound().build();\n    }\n}\n```",
        "testStrategy": "1. 다양한 주소 형식에 대한 변환 테스트\n2. 카카오 API 응답 파싱 테스트\n3. 예외 상황 처리 테스트 (API 호출 실패, 주소 찾기 실패 등)\n4. 응답 시간 측정 테스트\n5. 카카오 API 일일 사용량 제한 고려한 테스트",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "대피소 마커 표시 기능 구현",
        "description": "지도 위에 대피소 위치를 마커로 표시하는 기능 구현",
        "details": "1. 마커 표시 기능이 포함된 지도 컴포넌트 업데이트:\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\nimport axios from 'axios';\n\ninterface Shelter {\n  id: number;\n  name: string;\n  address: string;\n  latitude: number;\n  longitude: number;\n  capacity: number;\n  type: string;\n  contact: string;\n  distance: number;\n}\n\ninterface MapComponentProps {\n  searchAddress: string;\n}\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  const [center, setCenter] = useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  const [shelters, setShelters] = useState<Shelter[]>([]);\n  const [selectedShelter, setSelectedShelter] = useState<Shelter | null>(null);\n  \n  useEffect(() => {\n    if (searchAddress) {\n      // 주소로 대피소 검색\n      axios.get(`/api/shelters/search?address=${encodeURIComponent(searchAddress)}`)\n        .then(response => {\n          setShelters(response.data);\n          \n          if (response.data.length > 0) {\n            // 첫 번째 대피소 위치로 지도 중심 이동\n            setCenter({\n              lat: response.data[0].latitude,\n              lng: response.data[0].longitude\n            });\n          }\n        })\n        .catch(error => {\n          console.error('Error fetching shelters:', error);\n        });\n    }\n  }, [searchAddress]);\n  \n  const handleMarkerClick = (shelter: Shelter) => {\n    setSelectedShelter(shelter);\n  };\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3}\n      >\n        {shelters.map(shelter => (\n          <MapMarker\n            key={shelter.id}\n            position={{ lat: shelter.latitude, lng: shelter.longitude }}\n            onClick={() => handleMarkerClick(shelter)}\n            image={{\n              src: '/marker.png', // 마커 이미지 경로\n              size: { width: 24, height: 35 },\n            }}\n          />\n        ))}\n      </Map>\n      \n      {selectedShelter && (\n        <div className=\"shelter-info\">\n          <h3>{selectedShelter.name}</h3>\n          <p>주소: {selectedShelter.address}</p>\n          <p>수용 인원: {selectedShelter.capacity}명</p>\n          <p>유형: {selectedShelter.type}</p>\n          <p>연락처: {selectedShelter.contact}</p>\n          <p>거리: {(selectedShelter.distance / 1000).toFixed(2)}km</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MapComponent;\n```\n\n2. 마커 이미지 준비:\n   - public 폴더에 marker.png 파일 추가 (대피소 아이콘)\n\n3. 마커 클릭 시 표시할 대피소 정보 스타일 추가 (App.css):\n```css\n.shelter-info {\n  margin-top: 20px;\n  padding: 15px;\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.shelter-info h3 {\n  margin-top: 0;\n  color: #333;\n}\n\n.shelter-info p {\n  margin: 8px 0;\n  color: #555;\n}\n```\n\n4. API 요청을 위한 axios 인스턴스 설정 (src/services/api.ts):\n```typescript\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'http://localhost:8080', // 백엔드 서버 URL\n  timeout: 10000,\n});\n\nexport default api;\n```",
        "testStrategy": "1. 대피소 데이터 로딩 및 마커 표시 테스트\n2. 마커 클릭 이벤트 테스트\n3. 대피소 정보 표시 기능 테스트\n4. 다수의 마커가 있을 때 성능 테스트\n5. 마커 이미지 로딩 테스트",
        "priority": "medium",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "거리 계산 및 정렬 로직 구현",
        "description": "사용자 위치 기준으로 가장 가까운 대피소를 계산하고 정렬하는 로직 구현",
        "details": "1. 거리 계산 알고리즘 최적화:\n```java\n@Service\n@RequiredArgsConstructor\npublic class DistanceCalculationService {\n    private final ShelterRepository shelterRepository;\n    \n    // 지구 반경 (km)\n    private static final double EARTH_RADIUS = 6371;\n    \n    // 특정 좌표 주변의 대피소 검색 (성능 최적화 버전)\n    public List<Shelter> findNearbyShelters(double latitude, double longitude, double radiusInKm) {\n        // 위도 1도 차이 = 약 111km, 경도 1도 차이는 위도에 따라 다름\n        double latDiff = radiusInKm / 111.0;\n        double lonDiff = radiusInKm / (111.0 * Math.cos(Math.toRadians(latitude)));\n        \n        double minLat = latitude - latDiff;\n        double maxLat = latitude + latDiff;\n        double minLon = longitude - lonDiff;\n        double maxLon = longitude + lonDiff;\n        \n        // 대략적인 범위 내 대피소 조회 (DB 쿼리 최적화)\n        List<Shelter> candidateShelters = shelterRepository.findByLatitudeBetweenAndLongitudeBetween(\n                minLat, maxLat, minLon, maxLon);\n        \n        // 정확한 거리 계산 및 필터링\n        return candidateShelters.stream()\n                .filter(shelter -> calculateDistance(latitude, longitude, \n                        shelter.getLatitude(), shelter.getLongitude()) <= radiusInKm * 1000)\n                .collect(Collectors.toList());\n    }\n    \n    // 가장 가까운 N개 대피소 찾기\n    public List<ShelterDto> findNearestShelters(double latitude, double longitude, int limit) {\n        // 먼저 넓은 반경에서 후보 대피소 검색 (예: 10km)\n        List<Shelter> nearbyShelters = findNearbyShelters(latitude, longitude, 10.0);\n        \n        // 거리 계산 및 정렬\n        return nearbyShelters.stream()\n                .map(shelter -> {\n                    double distance = calculateDistance(latitude, longitude, \n                            shelter.getLatitude(), shelter.getLongitude());\n                    \n                    return ShelterDto.builder()\n                            .id(shelter.getId())\n                            .name(shelter.getName())\n                            .address(shelter.getAddress())\n                            .latitude(shelter.getLatitude())\n                            .longitude(shelter.getLongitude())\n                            .capacity(shelter.getCapacity())\n                            .type(shelter.getType())\n                            .contact(shelter.getContact())\n                            .distance(distance)\n                            .build();\n                })\n                .sorted(Comparator.comparing(ShelterDto::getDistance))\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n    \n    // 하버사인 공식을 사용한 두 좌표 간 거리 계산 (미터 단위)\n    public double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        double latDistance = Math.toRadians(lat2 - lat1);\n        double lonDistance = Math.toRadians(lon2 - lon1);\n        \n        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n        \n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        \n        return EARTH_RADIUS * c * 1000; // 미터 단위로 변환\n    }\n}\n```\n\n2. Repository 인터페이스 확장:\n```java\npublic interface ShelterRepository extends JpaRepository<Shelter, Long> {\n    List<Shelter> findByLatitudeBetweenAndLongitudeBetween(\n            double minLatitude, double maxLatitude, \n            double minLongitude, double maxLongitude);\n}\n```\n\n3. 서비스 계층 업데이트:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ShelterService {\n    private final ShelterRepository shelterRepository;\n    private final AddressService addressService;\n    private final DistanceCalculationService distanceService;\n    \n    // 기존 메소드들...\n    \n    public List<ShelterDto> findNearestShelters(Double latitude, Double longitude, int limit) {\n        return distanceService.findNearestShelters(latitude, longitude, limit);\n    }\n    \n    public List<ShelterDto> findSheltersByAddress(String address) {\n        // 주소를 좌표로 변환\n        Coordinates coords = addressService.getCoordinatesByAddress(address);\n        if (coords != null) {\n            return findNearestShelters(coords.getLatitude(), coords.getLongitude(), 10);\n        }\n        return Collections.emptyList();\n    }\n}\n```",
        "testStrategy": "1. 거리 계산 알고리즘 정확성 테스트\n2. 다양한 좌표 쌍에 대한 거리 계산 테스트\n3. 대량의 대피소 데이터에 대한 성능 테스트\n4. 경계 케이스 테스트 (예: 위도/경도 범위 경계)\n5. 정렬 결과 정확성 테스트",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "대피소 상세 정보 표시 기능 구현",
        "description": "선택된 대피소의 상세 정보를 표시하는 UI 컴포넌트 구현",
        "details": "1. 대피소 상세 정보 컴포넌트 구현:\n```tsx\nimport React from 'react';\nimport styled from 'styled-components';\n\ninterface Shelter {\n  id: number;\n  name: string;\n  address: string;\n  latitude: number;\n  longitude: number;\n  capacity: number;\n  type: string;\n  contact: string;\n  distance: number;\n}\n\ninterface ShelterDetailProps {\n  shelter: Shelter | null;\n  onClose: () => void;\n}\n\nconst DetailContainer = styled.div`\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: white;\n  padding: 20px;\n  border-radius: 15px 15px 0 0;\n  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  transform: translateY(${props => props.show ? '0' : '100%'});\n  transition: transform 0.3s ease-in-out;\n  max-height: 50vh;\n  overflow-y: auto;\n`;\n\nconst CloseButton = styled.button`\n  position: absolute;\n  top: 15px;\n  right: 15px;\n  background: none;\n  border: none;\n  font-size: 20px;\n  cursor: pointer;\n  color: #666;\n`;\n\nconst DetailTitle = styled.h2`\n  margin-top: 0;\n  margin-bottom: 15px;\n  color: #333;\n  font-size: 20px;\n`;\n\nconst DetailItem = styled.div`\n  margin-bottom: 10px;\n`;\n\nconst Label = styled.span`\n  font-weight: bold;\n  color: #555;\n  margin-right: 5px;\n`;\n\nconst Value = styled.span`\n  color: #333;\n`;\n\nconst DirectionsButton = styled.button`\n  background: #4285f4;\n  color: white;\n  border: none;\n  padding: 10px 15px;\n  border-radius: 4px;\n  margin-top: 15px;\n  cursor: pointer;\n  font-weight: bold;\n  &:hover {\n    background: #3367d6;\n  }\n`;\n\nconst ShelterDetail: React.FC<ShelterDetailProps> = ({ shelter, onClose }) => {\n  if (!shelter) return null;\n  \n  const openDirections = () => {\n    // 카카오맵 길찾기 URL 생성\n    const url = `https://map.kakao.com/link/to/${shelter.name},${shelter.latitude},${shelter.longitude}`;\n    window.open(url, '_blank');\n  };\n  \n  return (\n    <DetailContainer show={!!shelter}>\n      <CloseButton onClick={onClose}>×</CloseButton>\n      <DetailTitle>{shelter.name}</DetailTitle>\n      \n      <DetailItem>\n        <Label>주소:</Label>\n        <Value>{shelter.address}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>유형:</Label>\n        <Value>{shelter.type}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>수용 인원:</Label>\n        <Value>{shelter.capacity}명</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>연락처:</Label>\n        <Value>{shelter.contact || '정보 없음'}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>거리:</Label>\n        <Value>{(shelter.distance / 1000).toFixed(2)}km</Value>\n      </DetailItem>\n      \n      <DirectionsButton onClick={openDirections}>\n        길찾기\n      </DirectionsButton>\n    </DetailContainer>\n  );\n};\n\nexport default ShelterDetail;\n```\n\n2. MapComponent 업데이트하여 상세 정보 컴포넌트 통합:\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\nimport axios from 'axios';\nimport ShelterDetail from './ShelterDetail';\nimport api from '../services/api';\n\n// 인터페이스 정의 생략 (이전과 동일)\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  const [center, setCenter] = useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  const [shelters, setShelters] = useState<Shelter[]>([]);\n  const [selectedShelter, setSelectedShelter] = useState<Shelter | null>(null);\n  \n  useEffect(() => {\n    if (searchAddress) {\n      // 주소로 대피소 검색\n      api.get(`/api/shelters/search?address=${encodeURIComponent(searchAddress)}`)\n        .then(response => {\n          setShelters(response.data);\n          \n          if (response.data.length > 0) {\n            // 첫 번째 대피소 위치로 지도 중심 이동\n            setCenter({\n              lat: response.data[0].latitude,\n              lng: response.data[0].longitude\n            });\n          }\n        })\n        .catch(error => {\n          console.error('Error fetching shelters:', error);\n        });\n    }\n  }, [searchAddress]);\n  \n  const handleMarkerClick = (shelter: Shelter) => {\n    setSelectedShelter(shelter);\n  };\n  \n  const handleCloseDetail = () => {\n    setSelectedShelter(null);\n  };\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3}\n      >\n        {shelters.map(shelter => (\n          <MapMarker\n            key={shelter.id}\n            position={{ lat: shelter.latitude, lng: shelter.longitude }}\n            onClick={() => handleMarkerClick(shelter)}\n            image={{\n              src: '/marker.png',\n              size: { width: 24, height: 35 },\n            }}\n          />\n        ))}\n      </Map>\n      \n      <ShelterDetail \n        shelter={selectedShelter} \n        onClose={handleCloseDetail} \n      />\n    </div>\n  );\n};\n\nexport default MapComponent;\n```",
        "testStrategy": "1. 대피소 상세 정보 표시 기능 테스트\n2. 모달 열기/닫기 기능 테스트\n3. 길찾기 버튼 기능 테스트\n4. 다양한 화면 크기에서의 UI 테스트\n5. 누락된 정보 처리 테스트 (예: 연락처 없음)",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "반응형 디자인 적용",
        "description": "모바일 및 데스크톱 환경에 모두 대응하는 반응형 UI 구현",
        "details": "1. 반응형 스타일 컴포넌트 설정:\n```tsx\n// src/styles/responsive.ts\nimport { css } from 'styled-components';\n\nexport const breakpoints = {\n  mobile: 576,\n  tablet: 768,\n  desktop: 992,\n};\n\nexport const media = {\n  mobile: (...args) => css`\n    @media (max-width: ${breakpoints.mobile}px) {\n      ${css(...args)};\n    }\n  `,\n  tablet: (...args) => css`\n    @media (min-width: ${breakpoints.mobile + 1}px) and (max-width: ${breakpoints.tablet}px) {\n      ${css(...args)};\n    }\n  `,\n  desktop: (...args) => css`\n    @media (min-width: ${breakpoints.tablet + 1}px) {\n      ${css(...args)};\n    }\n  `,\n};\n```\n\n2. 반응형 레이아웃 컴포넌트 구현:\n```tsx\n// src/components/Layout.tsx\nimport React from 'react';\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\nconst Container = styled.div`\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 20px;\n  \n  ${media.mobile`\n    padding: 0 10px;\n  `}\n`;\n\nconst Header = styled.header`\n  padding: 20px 0;\n  text-align: center;\n  \n  ${media.mobile`\n    padding: 15px 0;\n  `}\n`;\n\nconst Title = styled.h1`\n  font-size: 28px;\n  color: #333;\n  margin: 0;\n  \n  ${media.mobile`\n    font-size: 22px;\n  `}\n`;\n\nconst Main = styled.main`\n  min-height: calc(100vh - 120px);\n`;\n\nconst Footer = styled.footer`\n  padding: 20px 0;\n  text-align: center;\n  color: #666;\n  font-size: 14px;\n  \n  ${media.mobile`\n    padding: 15px 0;\n    font-size: 12px;\n  `}\n`;\n\ninterface LayoutProps {\n  children: React.ReactNode;\n}\n\nconst Layout: React.FC<LayoutProps> = ({ children }) => {\n  return (\n    <Container>\n      <Header>\n        <Title>대피소 찾기 서비스</Title>\n      </Header>\n      <Main>{children}</Main>\n      <Footer>\n        &copy; {new Date().getFullYear()} SafetyFirst. All rights reserved.\n      </Footer>\n    </Container>\n  );\n};\n\nexport default Layout;\n```\n\n3. 반응형 지도 컴포넌트 업데이트:\n```tsx\n// MapComponent.tsx 업데이트\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\n// 기존 코드...\n\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 600px;\n  margin-bottom: 20px;\n  \n  ${media.mobile`\n    height: 400px;\n    margin-bottom: 10px;\n  `}\n`;\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  // 기존 코드...\n  \n  return (\n    <MapContainer>\n      <Map\n        center={center}\n        style={{ width: '100%', height: '100%' }}\n        level={3}\n      >\n        {/* 마커 코드... */}\n      </Map>\n      \n      <ShelterDetail \n        shelter={selectedShelter} \n        onClose={handleCloseDetail} \n      />\n    </MapContainer>\n  );\n};\n```\n\n4. 반응형 검색 컴포넌트 업데이트:\n```tsx\n// AddressSearch.tsx 업데이트\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\n// 기존 코드...\n\nconst SearchContainer = styled.div`\n  width: 100%;\n  max-width: 500px;\n  margin: 20px auto;\n  position: relative;\n  \n  ${media.mobile`\n    max-width: 100%;\n    margin: 10px auto;\n  `}\n`;\n\nconst SearchInput = styled.input`\n  width: 100%;\n  padding: 12px 15px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  \n  ${media.mobile`\n    padding: 10px;\n    font-size: 14px;\n  `}\n  \n  &:focus {\n    outline: none;\n    border-color: #4285f4;\n  }\n`;\n\n// 나머지 코드...\n```\n\n5. App.tsx에 레이아웃 적용:\n```tsx\nimport React, { useState } from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\nimport AddressSearch from './components/AddressSearch';\nimport Layout from './components/Layout';\n\nfunction App() {\n  const [searchAddress, setSearchAddress] = useState('');\n  \n  const handleSearch = (address: string) => {\n    setSearchAddress(address);\n  };\n  \n  return (\n    <Layout>\n      <AddressSearch onSearch={handleSearch} />\n      <MapComponent searchAddress={searchAddress} />\n    </Layout>\n  );\n}\n\nexport default App;\n```\n\n6. 글로벌 스타일 추가 (src/styles/GlobalStyle.ts):\n```tsx\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    box-sizing: border-box;\n  }\n  \n  body {\n    margin: 0;\n    padding: 0;\n    font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    background-color: #f9f9f9;\n  }\n`;\n\nexport default GlobalStyle;\n```\n\n7. index.tsx에 글로벌 스타일 적용:\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport GlobalStyle from './styles/GlobalStyle';\n\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```",
        "testStrategy": "1. 다양한 화면 크기에서의 레이아웃 테스트 (모바일, 태블릿, 데스크톱)\n2. 브라우저 호환성 테스트 (Chrome, Firefox, Safari, Edge)\n3. 반응형 요소들의 동작 확인\n4. 모바일 터치 인터랙션 테스트\n5. 다양한 기기에서의 사용성 테스트",
        "priority": "low",
        "dependencies": [
          5,
          8,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "코드 최적화 및 문서화",
        "description": "코드 리팩토링, 주석 추가, 문서화 및 최종 테스트",
        "details": "1. 코드 리팩토링:\n   - 중복 코드 제거\n   - 컴포넌트 분리 및 재사용성 향상\n   - 성능 최적화 (불필요한 렌더링 방지)\n   - 타입 정의 개선\n\n2. 주석 추가:\n   - 각 컴포넌트 및 함수에 JSDoc 형식의 주석 추가\n   - 복잡한 로직에 대한 설명 추가\n   - 예시:\n   ```typescript\n   /**\n    * 두 지리적 좌표 사이의 거리를 계산합니다.\n    * @param lat1 - 첫 번째 위치의 위도\n    * @param lon1 - 첫 번째 위치의 경도\n    * @param lat2 - 두 번째 위치의 위도\n    * @param lon2 - 두 번째 위치의 경도\n    * @returns 두 위치 사이의 거리 (미터 단위)\n    */\n   function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n     // 구현...\n   }\n   ```\n\n3. 에러 처리 개선:\n   - 사용자 친화적인 에러 메시지 표시\n   - 에러 발생 시 대체 UI 제공\n   - 예시:\n   ```typescript\n   const ErrorMessage = styled.div`\n     color: #d32f2f;\n     background-color: #ffebee;\n     padding: 10px;\n     border-radius: 4px;\n     margin: 10px 0;\n     text-align: center;\n   `;\n   \n   // 컴포넌트 내부\n   const [error, setError] = useState<string | null>(null);\n   \n   // API 호출 부분\n   api.get('/api/shelters/search')\n     .then(response => {\n       // 성공 처리\n     })\n     .catch(err => {\n       console.error('API 호출 실패:', err);\n       setError('대피소 정보를 불러오는데 실패했습니다. 잠시 후 다시 시도해주세요.');\n     });\n   \n   // 렌더링 부분\n   {error && <ErrorMessage>{error}</ErrorMessage>}\n   ```\n\n4. 로딩 상태 처리:\n   - 데이터 로딩 중 스켈레톤 UI 또는 로딩 인디케이터 표시\n   - 예시:\n   ```typescript\n   const LoadingSpinner = styled.div`\n     display: flex;\n     justify-content: center;\n     align-items: center;\n     height: 200px;\n   `;\n   \n   // 컴포넌트 내부\n   const [loading, setLoading] = useState(false);\n   \n   // API 호출 부분\n   setLoading(true);\n   api.get('/api/shelters/search')\n     .then(response => {\n       // 성공 처리\n     })\n     .catch(err => {\n       // 에러 처리\n     })\n     .finally(() => {\n       setLoading(false);\n     });\n   \n   // 렌더링 부분\n   {loading ? (\n     <LoadingSpinner>\n       <div className=\"spinner\"></div>\n     </LoadingSpinner>\n   ) : (\n     // 실제 컨텐츠\n   )}\n   ```\n\n5. README.md 작성:\n   - 프로젝트 개요\n   - 설치 방법\n   - 실행 방법\n   - API 문서\n   - 폴더 구조 설명\n   - 기술 스택 소개\n   - 기여 방법\n\n6. API 문서화:\n   - Swagger 또는 Spring REST Docs를 사용한 API 문서화\n   - 예시 (Swagger 설정):\n   ```java\n   @Configuration\n   @EnableSwagger2\n   public class SwaggerConfig {\n       @Bean\n       public Docket api() {\n           return new Docket(DocumentationType.SWAGGER_2)\n                   .select()\n                   .apis(RequestHandlerSelectors.basePackage(\"com.safetyfirst.controller\"))\n                   .paths(PathSelectors.any())\n                   .build()\n                   .apiInfo(apiInfo());\n       }\n       \n       private ApiInfo apiInfo() {\n           return new ApiInfoBuilder()\n                   .title(\"SafetyFirst API\")\n                   .description(\"대피소 찾기 서비스 API 문서\")\n                   .version(\"1.0.0\")\n                   .build();\n       }\n   }\n   ```\n\n7. 최종 테스트:\n   - 모든 기능에 대한 종합 테스트\n   - 크로스 브라우저 테스트\n   - 성능 테스트\n   - 사용성 테스트",
        "testStrategy": "1. 코드 품질 검사 도구 실행 (ESLint, SonarQube 등)\n2. 단위 테스트 및 통합 테스트 실행\n3. 성능 테스트 (로딩 시간, 메모리 사용량 등)\n4. 크로스 브라우저 테스트\n5. 코드 리뷰 진행\n6. 문서 정확성 검증",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-01T07:59:04.207Z",
      "updated": "2025-07-07T08:22:50.195Z",
      "description": "백엔드 개발 작업 (Spring Boot + MySQL, API 개발)"
    }
  },
  "frontend-dev": {
    "tasks": [
      {
        "id": 1,
        "title": "프로젝트 초기 설정 및 저장소 구성",
        "description": "프론트엔드(TypeScript, React) 프로젝트 구조 설정 및 Git 저장소 초기화, 백엔드 설정은 추후 진행",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "1. 프론트엔드 설정 (우선 진행):\n   - Create React App with TypeScript 템플릿 사용\n   - 필요한 패키지 설치: axios, styled-components, kakao-maps-sdk\n   - ESLint 및 Prettier 설정\n   - 모듈화된 폴더 구조 생성:\n     * components: 재사용 가능한 UI 컴포넌트\n     * services: API 호출 및 데이터 처리 로직\n     * utils: 유틸리티 함수\n     * types: TypeScript 타입 정의\n     * hooks: 커스텀 React 훅\n     * contexts: 전역 상태 관리\n   - 카카오 맵 API 연동을 위한 기본 구조 설정\n   - 초보자를 위한 명확한 주석 및 일관된 코드 스타일 적용\n\n2. Git 저장소 설정:\n   - .gitignore 파일 생성 (node_modules, build 폴더 등 제외)\n   - README.md 작성 (프로젝트 설명, 설치 방법, 실행 방법, 폴더 구조 설명 등)\n   - 초기 커밋\n\n3. 백엔드 설정 (추후 진행):\n   - Spring Boot 프로젝트 설정은 프론트엔드 개발 진행 후 별도 작업으로 연기",
        "testStrategy": "1. 프론트엔드: \n   - npm start로 React 앱 실행 확인\n   - 카카오 맵 API 기본 연동 테스트\n   - 모듈 구조 검토 및 코드 품질 확인\n2. Git 저장소 정상 작동 확인",
        "subtasks": [
          {
            "id": 1,
            "title": "React + TypeScript 프로젝트 초기화",
            "description": "Create React App을 사용하여 TypeScript 기반 프로젝트 생성",
            "status": "done",
            "dependencies": [],
            "details": "<info added on 2025-07-01T08:15:56.848Z>\n✅ **React + TypeScript 프로젝트 초기화 완료**\n\n**완료된 작업:**\n- React + TypeScript 프로젝트 생성 완료\n- 기본 패키지 설치 (axios, styled-components, @types/styled-components)\n- 모듈화된 폴더 구조 생성 (/types, /services, /utils, /hooks, /components, /contexts)\n\n**생성된 파일들:**\n- `/types/index.ts` - TypeScript 타입 정의 (Coordinates, Shelter, MapMarker 등)\n- `/utils/index.ts` - 유틸리티 함수들 (거리 계산, 포맷팅, 디바운스 등)\n- `/services/index.ts` - API 서비스 (대피소 검색, 주소 검색, 위치 서비스 등)\n- `/hooks/index.ts` - 커스텀 훅들 (useLocation, useShelters, useAddressSearch 등)\n\n**다음 단계:** 카카오 맵 기본 컴포넌트 생성 및 HTML에 script 태그 추가\n</info added on 2025-07-01T08:15:56.848Z>",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "필요 패키지 설치 및 개발 환경 구성",
            "description": "axios, styled-components, kakao-maps-sdk 설치 및 ESLint/Prettier 설정",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "모듈화된 폴더 구조 생성",
            "description": "components, services, utils, types, hooks, contexts 등 폴더 구조 설정",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "카카오 맵 API 기본 연동 구조 설정",
            "description": "카카오 맵 API 키 설정 및 기본 지도 컴포넌트 구현",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "코드 스타일 가이드 및 주석 규칙 수립",
            "description": "초보자도 이해하기 쉬운 주석 및 코드 스타일 가이드 작성",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Git 저장소 설정",
            "description": ".gitignore 생성, README.md 작성 및 초기 커밋",
            "status": "done",
            "dependencies": [],
            "details": "",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "데이터베이스 스키마 설계 및 구현",
        "description": "대피소 정보를 저장할 MySQL 데이터베이스 스키마 설계 및 JPA 엔티티 구현",
        "details": "1. 데이터베이스 스키마 설계:\n   - shelter 테이블 생성 (대피소 정보 저장)\n     - id: BIGINT (PK, AUTO_INCREMENT)\n     - name: VARCHAR(100) (대피소 이름)\n     - address: VARCHAR(255) (주소)\n     - latitude: DOUBLE (위도)\n     - longitude: DOUBLE (경도)\n     - capacity: INT (수용 인원)\n     - type: VARCHAR(50) (대피소 유형)\n     - contact: VARCHAR(20) (연락처)\n     - created_at: TIMESTAMP\n     - updated_at: TIMESTAMP\n\n2. JPA 엔티티 클래스 구현:\n```java\n@Entity\n@Table(name = \"shelter\")\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class Shelter {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n    \n    private String name;\n    private String address;\n    private Double latitude;\n    private Double longitude;\n    private Integer capacity;\n    private String type;\n    private String contact;\n    \n    @CreationTimestamp\n    private LocalDateTime createdAt;\n    \n    @UpdateTimestamp\n    private LocalDateTime updatedAt;\n}\n```\n\n3. Repository 인터페이스 생성:\n```java\npublic interface ShelterRepository extends JpaRepository<Shelter, Long> {\n    List<Shelter> findTop10ByOrderByIdAsc();\n}\n```",
        "testStrategy": "1. MySQL 데이터베이스 연결 테스트\n2. JPA 엔티티 매핑 테스트\n3. 간단한 CRUD 작업 테스트로 Repository 기능 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "카카오 맵 API 연동 및 기본 지도 화면 구현",
        "description": "카카오 맵 API를 React 프로젝트에 연동하고 기본 지도 화면 구현",
        "details": "1. 카카오 맵 API 키 발급:\n   - 카카오 개발자 사이트(https://developers.kakao.com)에서 애플리케이션 등록\n   - JavaScript 키 발급 및 도메인 설정\n\n2. 카카오 맵 SDK 설치 및 설정:\n   - npm install react-kakao-maps-sdk\n   - public/index.html에 스크립트 추가:\n   ```html\n   <script type=\"text/javascript\" src=\"//dapi.kakao.com/v2/maps/sdk.js?appkey=발급받은키&libraries=services\"></script>\n   ```\n\n3. 기본 지도 컴포넌트 구현:\n```tsx\nimport React from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\n\nconst MapComponent: React.FC = () => {\n  // 서울시청 좌표 (초기 중심점)\n  const [center, setCenter] = React.useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3} // 지도 확대 레벨\n      />\n    </div>\n  );\n};\n\nexport default MapComponent;\n```\n\n4. App.tsx에 지도 컴포넌트 추가:\n```tsx\nimport React from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>대피소 찾기 서비스</h1>\n      </header>\n      <main>\n        <MapComponent />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n```",
        "testStrategy": "1. 카카오 맵이 정상적으로 렌더링되는지 확인\n2. 지도 확대/축소 기능 테스트\n3. 지도 이동 기능 테스트\n4. 다양한 브라우저에서 호환성 테스트",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "공공데이터 API 연동 및 대피소 데이터 수집",
        "description": "공공데이터 포털에서 대피소 정보를 가져와 데이터베이스에 저장하는 기능 구현",
        "details": "1. 공공데이터 포털 API 키 발급:\n   - 공공데이터 포털(https://www.data.go.kr)에서 회원가입 및 로그인\n   - 민방위 대피시설 API 활용 신청 및 인증키 발급\n\n2. API 호출 서비스 구현:\n```java\n@Service\n@RequiredArgsConstructor\npublic class PublicDataService {\n    private final ShelterRepository shelterRepository;\n    private final RestTemplate restTemplate;\n    \n    private static final String API_URL = \"http://api.data.go.kr/openapi/tn_pubr_public_civil_defense_shelter_api\";\n    private static final String API_KEY = \"발급받은키\";\n    \n    @Scheduled(cron = \"0 0 0 * * ?\") // 매일 자정에 실행\n    public void fetchAndSaveShelterData() {\n        try {\n            String url = API_URL + \"?serviceKey=\" + API_KEY + \"&type=json&numOfRows=1000&pageNo=1\";\n            ResponseEntity<ShelterApiResponse> response = restTemplate.getForEntity(url, ShelterApiResponse.class);\n            \n            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {\n                List<ShelterApiItem> items = response.getBody().getResponse().getBody().getItems();\n                \n                for (ShelterApiItem item : items) {\n                    Shelter shelter = Shelter.builder()\n                        .name(item.getFcltyNm())\n                        .address(item.getRefineRoadnmAddr())\n                        .latitude(Double.parseDouble(item.getRefineWgs84Lat()))\n                        .longitude(Double.parseDouble(item.getRefineWgs84Logt()))\n                        .capacity(Integer.parseInt(item.getFcltyAr()))\n                        .type(item.getShelterDivType())\n                        .contact(item.getMngdptCd())\n                        .build();\n                    \n                    shelterRepository.save(shelter);\n                }\n            }\n        } catch (Exception e) {\n            // 로깅 및 예외 처리\n        }\n    }\n}\n```\n\n3. API 응답 DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\npublic class ShelterApiResponse {\n    private Response response;\n    \n    @Getter @Setter\n    public static class Response {\n        private Header header;\n        private Body body;\n    }\n    \n    @Getter @Setter\n    public static class Header {\n        private String resultCode;\n        private String resultMsg;\n    }\n    \n    @Getter @Setter\n    public static class Body {\n        private List<ShelterApiItem> items;\n        private int numOfRows;\n        private int pageNo;\n        private int totalCount;\n    }\n}\n\n@Getter @Setter\n@NoArgsConstructor\npublic class ShelterApiItem {\n    private String fcltyNm; // 시설명\n    private String refineRoadnmAddr; // 도로명주소\n    private String refineWgs84Lat; // 위도\n    private String refineWgs84Logt; // 경도\n    private String fcltyAr; // 시설면적\n    private String shelterDivType; // 대피소 구분\n    private String mngdptCd; // 관리부서\n}\n```\n\n4. RestTemplate 설정:\n```java\n@Configuration\npublic class RestTemplateConfig {\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```",
        "testStrategy": "1. 공공데이터 API 호출 테스트\n2. 응답 데이터 파싱 테스트\n3. 데이터베이스 저장 기능 테스트\n4. 스케줄링 기능 테스트\n5. 예외 처리 테스트",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "주소 검색 UI 컴포넌트 개발",
        "description": "사용자가 주소를 입력하고 검색할 수 있는 UI 컴포넌트 개발 및 자동완성 기능 구현",
        "details": "1. 주소 검색 컴포넌트 구현:\n```tsx\nimport React, { useState } from 'react';\nimport styled from 'styled-components';\n\ninterface SearchProps {\n  onSearch: (address: string) => void;\n}\n\nconst SearchContainer = styled.div`\n  width: 100%;\n  max-width: 500px;\n  margin: 20px auto;\n  position: relative;\n`;\n\nconst SearchInput = styled.input`\n  width: 100%;\n  padding: 12px 15px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  &:focus {\n    outline: none;\n    border-color: #4285f4;\n  }\n`;\n\nconst SearchButton = styled.button`\n  position: absolute;\n  right: 5px;\n  top: 5px;\n  background: #4285f4;\n  color: white;\n  border: none;\n  border-radius: 4px;\n  padding: 8px 15px;\n  cursor: pointer;\n  &:hover {\n    background: #3367d6;\n  }\n`;\n\nconst SuggestionList = styled.ul`\n  list-style: none;\n  padding: 0;\n  margin: 0;\n  position: absolute;\n  width: 100%;\n  background: white;\n  border: 1px solid #ddd;\n  border-top: none;\n  border-radius: 0 0 4px 4px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  z-index: 10;\n`;\n\nconst SuggestionItem = styled.li`\n  padding: 10px 15px;\n  cursor: pointer;\n  &:hover {\n    background: #f5f5f5;\n  }\n`;\n\nconst AddressSearch: React.FC<SearchProps> = ({ onSearch }) => {\n  const [address, setAddress] = useState('');\n  const [suggestions, setSuggestions] = useState<string[]>([]);\n\n  // 카카오 주소 검색 API 사용\n  const searchAddress = (query: string) => {\n    if (!query.trim()) return;\n    \n    // 카카오 주소 검색 API 호출\n    const geocoder = new window.kakao.maps.services.Geocoder();\n    geocoder.addressSearch(query, (result: any[], status: string) => {\n      if (status === window.kakao.maps.services.Status.OK) {\n        const addresses = result.map(item => item.address_name);\n        setSuggestions(addresses);\n      }\n    });\n  };\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const value = e.target.value;\n    setAddress(value);\n    if (value.length > 2) {\n      searchAddress(value);\n    } else {\n      setSuggestions([]);\n    }\n  };\n\n  const handleSearch = () => {\n    if (address.trim()) {\n      onSearch(address);\n      setSuggestions([]);\n    }\n  };\n\n  const handleSuggestionClick = (suggestion: string) => {\n    setAddress(suggestion);\n    onSearch(suggestion);\n    setSuggestions([]);\n  };\n\n  return (\n    <SearchContainer>\n      <SearchInput\n        type=\"text\"\n        placeholder=\"주소를 입력하세요\"\n        value={address}\n        onChange={handleInputChange}\n        onKeyPress={(e) => e.key === 'Enter' && handleSearch()}\n      />\n      <SearchButton onClick={handleSearch}>검색</SearchButton>\n      \n      {suggestions.length > 0 && (\n        <SuggestionList>\n          {suggestions.map((suggestion, index) => (\n            <SuggestionItem\n              key={index}\n              onClick={() => handleSuggestionClick(suggestion)}\n            >\n              {suggestion}\n            </SuggestionItem>\n          ))}\n        </SuggestionList>\n      )}\n    </SearchContainer>\n  );\n};\n\nexport default AddressSearch;\n```\n\n2. App.tsx에 주소 검색 컴포넌트 추가:\n```tsx\nimport React, { useState } from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\nimport AddressSearch from './components/AddressSearch';\n\nfunction App() {\n  const [searchAddress, setSearchAddress] = useState('');\n  \n  const handleSearch = (address: string) => {\n    setSearchAddress(address);\n    // 추후 백엔드 API 호출 로직 추가\n  };\n  \n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>대피소 찾기 서비스</h1>\n      </header>\n      <main>\n        <AddressSearch onSearch={handleSearch} />\n        <MapComponent searchAddress={searchAddress} />\n      </main>\n    </div>\n  );\n}\n\nexport default App;\n```",
        "testStrategy": "1. 주소 입력 및 검색 기능 테스트\n2. 자동완성 기능 테스트\n3. 엔터 키 및 검색 버튼 동작 테스트\n4. 검색 결과가 상위 컴포넌트로 올바르게 전달되는지 확인\n5. 다양한 주소 형식에 대한 테스트",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "in-progress",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "REST API 설계 및 구현",
        "description": "프론트엔드와 통신할 REST API 엔드포인트 설계 및 구현",
        "details": "1. REST API 컨트롤러 구현:\n```java\n@RestController\n@RequestMapping(\"/api/shelters\")\n@RequiredArgsConstructor\npublic class ShelterController {\n    private final ShelterService shelterService;\n    \n    @GetMapping\n    public ResponseEntity<List<ShelterDto>> getAllShelters() {\n        List<ShelterDto> shelters = shelterService.getAllShelters();\n        return ResponseEntity.ok(shelters);\n    }\n    \n    @GetMapping(\"/{id}\")\n    public ResponseEntity<ShelterDto> getShelterById(@PathVariable Long id) {\n        return shelterService.getShelterById(id)\n                .map(ResponseEntity::ok)\n                .orElse(ResponseEntity.notFound().build());\n    }\n    \n    @GetMapping(\"/nearest\")\n    public ResponseEntity<List<ShelterDto>> getNearestShelters(\n            @RequestParam Double latitude,\n            @RequestParam Double longitude,\n            @RequestParam(defaultValue = \"10\") int limit) {\n        List<ShelterDto> shelters = shelterService.findNearestShelters(latitude, longitude, limit);\n        return ResponseEntity.ok(shelters);\n    }\n    \n    @GetMapping(\"/search\")\n    public ResponseEntity<List<ShelterDto>> searchSheltersByAddress(@RequestParam String address) {\n        List<ShelterDto> shelters = shelterService.findSheltersByAddress(address);\n        return ResponseEntity.ok(shelters);\n    }\n}\n```\n\n2. 서비스 계층 구현:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ShelterService {\n    private final ShelterRepository shelterRepository;\n    private final AddressService addressService;\n    \n    public List<ShelterDto> getAllShelters() {\n        return shelterRepository.findAll().stream()\n                .map(this::convertToDto)\n                .collect(Collectors.toList());\n    }\n    \n    public Optional<ShelterDto> getShelterById(Long id) {\n        return shelterRepository.findById(id)\n                .map(this::convertToDto);\n    }\n    \n    public List<ShelterDto> findNearestShelters(Double latitude, Double longitude, int limit) {\n        // 모든 대피소를 가져와서 거리 계산 후 정렬\n        List<Shelter> allShelters = shelterRepository.findAll();\n        \n        return allShelters.stream()\n                .map(shelter -> {\n                    ShelterDto dto = convertToDto(shelter);\n                    double distance = calculateDistance(latitude, longitude, \n                                                       shelter.getLatitude(), shelter.getLongitude());\n                    dto.setDistance(distance);\n                    return dto;\n                })\n                .sorted(Comparator.comparing(ShelterDto::getDistance))\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n    \n    public List<ShelterDto> findSheltersByAddress(String address) {\n        // 주소를 좌표로 변환\n        Coordinates coords = addressService.getCoordinatesByAddress(address);\n        if (coords != null) {\n            return findNearestShelters(coords.getLatitude(), coords.getLongitude(), 10);\n        }\n        return Collections.emptyList();\n    }\n    \n    private ShelterDto convertToDto(Shelter shelter) {\n        return ShelterDto.builder()\n                .id(shelter.getId())\n                .name(shelter.getName())\n                .address(shelter.getAddress())\n                .latitude(shelter.getLatitude())\n                .longitude(shelter.getLongitude())\n                .capacity(shelter.getCapacity())\n                .type(shelter.getType())\n                .contact(shelter.getContact())\n                .build();\n    }\n    \n    // 하버사인 공식을 사용한 두 좌표 간 거리 계산 (미터 단위)\n    private double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        final int R = 6371; // 지구 반경 (km)\n        \n        double latDistance = Math.toRadians(lat2 - lat1);\n        double lonDistance = Math.toRadians(lon2 - lon1);\n        \n        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n        \n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        \n        return R * c * 1000; // 미터 단위로 변환\n    }\n}\n```\n\n3. DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\n@Builder\npublic class ShelterDto {\n    private Long id;\n    private String name;\n    private String address;\n    private Double latitude;\n    private Double longitude;\n    private Integer capacity;\n    private String type;\n    private String contact;\n    private Double distance; // 사용자 위치로부터의 거리 (미터)\n}\n\n@Getter @Setter\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Coordinates {\n    private Double latitude;\n    private Double longitude;\n}\n```",
        "testStrategy": "1. 각 API 엔드포인트에 대한 단위 테스트 작성\n2. Postman 또는 Swagger를 사용한 API 수동 테스트\n3. 거리 계산 알고리즘 정확성 테스트\n4. 다양한 입력값에 대한 예외 처리 테스트\n5. 응답 시간 및 성능 테스트",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "주소-좌표 변환 서비스 구현",
        "description": "주소를 위도/경도 좌표로 변환하는 서비스 구현",
        "details": "1. 주소 변환 서비스 구현:\n```java\n@Service\npublic class AddressService {\n    private final RestTemplate restTemplate;\n    private final String kakaoApiKey;\n    \n    public AddressService(RestTemplate restTemplate, @Value(\"${kakao.api.key}\") String kakaoApiKey) {\n        this.restTemplate = restTemplate;\n        this.kakaoApiKey = kakaoApiKey;\n    }\n    \n    public Coordinates getCoordinatesByAddress(String address) {\n        try {\n            String url = \"https://dapi.kakao.com/v2/local/search/address.json?query=\" + URLEncoder.encode(address, \"UTF-8\");\n            \n            HttpHeaders headers = new HttpHeaders();\n            headers.set(\"Authorization\", \"KakaoAK \" + kakaoApiKey);\n            \n            HttpEntity<String> entity = new HttpEntity<>(headers);\n            \n            ResponseEntity<KakaoAddressResponse> response = restTemplate.exchange(\n                url, HttpMethod.GET, entity, KakaoAddressResponse.class);\n            \n            if (response.getStatusCode() == HttpStatus.OK && response.getBody() != null) {\n                List<KakaoAddressDocument> documents = response.getBody().getDocuments();\n                if (!documents.isEmpty()) {\n                    KakaoAddressDocument document = documents.get(0);\n                    return new Coordinates(\n                        Double.parseDouble(document.getY()),\n                        Double.parseDouble(document.getX())\n                    );\n                }\n            }\n            return null;\n        } catch (Exception e) {\n            // 로깅 및 예외 처리\n            return null;\n        }\n    }\n}\n```\n\n2. 카카오 API 응답 DTO 클래스 구현:\n```java\n@Getter @Setter\n@NoArgsConstructor\npublic class KakaoAddressResponse {\n    private List<KakaoAddressDocument> documents;\n}\n\n@Getter @Setter\n@NoArgsConstructor\npublic class KakaoAddressDocument {\n    private String address_name;\n    private String x; // 경도\n    private String y; // 위도\n}\n```\n\n3. application.properties에 카카오 API 키 설정:\n```properties\nkakao.api.key=발급받은키\n```\n\n4. 컨트롤러에 주소 변환 API 추가:\n```java\n@RestController\n@RequestMapping(\"/api/address\")\n@RequiredArgsConstructor\npublic class AddressController {\n    private final AddressService addressService;\n    \n    @GetMapping(\"/coordinates\")\n    public ResponseEntity<Coordinates> getCoordinates(@RequestParam String address) {\n        Coordinates coordinates = addressService.getCoordinatesByAddress(address);\n        if (coordinates != null) {\n            return ResponseEntity.ok(coordinates);\n        }\n        return ResponseEntity.notFound().build();\n    }\n}\n```",
        "testStrategy": "1. 다양한 주소 형식에 대한 변환 테스트\n2. 카카오 API 응답 파싱 테스트\n3. 예외 상황 처리 테스트 (API 호출 실패, 주소 찾기 실패 등)\n4. 응답 시간 측정 테스트\n5. 카카오 API 일일 사용량 제한 고려한 테스트",
        "priority": "high",
        "dependencies": [
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "대피소 마커 표시 기능 구현",
        "description": "지도 위에 대피소 위치를 마커로 표시하는 기능 구현",
        "details": "1. 마커 표시 기능이 포함된 지도 컴포넌트 업데이트:\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\nimport axios from 'axios';\n\ninterface Shelter {\n  id: number;\n  name: string;\n  address: string;\n  latitude: number;\n  longitude: number;\n  capacity: number;\n  type: string;\n  contact: string;\n  distance: number;\n}\n\ninterface MapComponentProps {\n  searchAddress: string;\n}\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  const [center, setCenter] = useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  const [shelters, setShelters] = useState<Shelter[]>([]);\n  const [selectedShelter, setSelectedShelter] = useState<Shelter | null>(null);\n  \n  useEffect(() => {\n    if (searchAddress) {\n      // 주소로 대피소 검색\n      axios.get(`/api/shelters/search?address=${encodeURIComponent(searchAddress)}`)\n        .then(response => {\n          setShelters(response.data);\n          \n          if (response.data.length > 0) {\n            // 첫 번째 대피소 위치로 지도 중심 이동\n            setCenter({\n              lat: response.data[0].latitude,\n              lng: response.data[0].longitude\n            });\n          }\n        })\n        .catch(error => {\n          console.error('Error fetching shelters:', error);\n        });\n    }\n  }, [searchAddress]);\n  \n  const handleMarkerClick = (shelter: Shelter) => {\n    setSelectedShelter(shelter);\n  };\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3}\n      >\n        {shelters.map(shelter => (\n          <MapMarker\n            key={shelter.id}\n            position={{ lat: shelter.latitude, lng: shelter.longitude }}\n            onClick={() => handleMarkerClick(shelter)}\n            image={{\n              src: '/marker.png', // 마커 이미지 경로\n              size: { width: 24, height: 35 },\n            }}\n          />\n        ))}\n      </Map>\n      \n      {selectedShelter && (\n        <div className=\"shelter-info\">\n          <h3>{selectedShelter.name}</h3>\n          <p>주소: {selectedShelter.address}</p>\n          <p>수용 인원: {selectedShelter.capacity}명</p>\n          <p>유형: {selectedShelter.type}</p>\n          <p>연락처: {selectedShelter.contact}</p>\n          <p>거리: {(selectedShelter.distance / 1000).toFixed(2)}km</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default MapComponent;\n```\n\n2. 마커 이미지 준비:\n   - public 폴더에 marker.png 파일 추가 (대피소 아이콘)\n\n3. 마커 클릭 시 표시할 대피소 정보 스타일 추가 (App.css):\n```css\n.shelter-info {\n  margin-top: 20px;\n  padding: 15px;\n  background-color: #f8f9fa;\n  border-radius: 8px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n}\n\n.shelter-info h3 {\n  margin-top: 0;\n  color: #333;\n}\n\n.shelter-info p {\n  margin: 8px 0;\n  color: #555;\n}\n```\n\n4. API 요청을 위한 axios 인스턴스 설정 (src/services/api.ts):\n```typescript\nimport axios from 'axios';\n\nconst api = axios.create({\n  baseURL: 'http://localhost:8080', // 백엔드 서버 URL\n  timeout: 10000,\n});\n\nexport default api;\n```",
        "testStrategy": "1. 대피소 데이터 로딩 및 마커 표시 테스트\n2. 마커 클릭 이벤트 테스트\n3. 대피소 정보 표시 기능 테스트\n4. 다수의 마커가 있을 때 성능 테스트\n5. 마커 이미지 로딩 테스트",
        "priority": "medium",
        "dependencies": [
          3,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "거리 계산 및 정렬 로직 구현",
        "description": "사용자 위치 기준으로 가장 가까운 대피소를 계산하고 정렬하는 로직 구현",
        "details": "1. 거리 계산 알고리즘 최적화:\n```java\n@Service\n@RequiredArgsConstructor\npublic class DistanceCalculationService {\n    private final ShelterRepository shelterRepository;\n    \n    // 지구 반경 (km)\n    private static final double EARTH_RADIUS = 6371;\n    \n    // 특정 좌표 주변의 대피소 검색 (성능 최적화 버전)\n    public List<Shelter> findNearbyShelters(double latitude, double longitude, double radiusInKm) {\n        // 위도 1도 차이 = 약 111km, 경도 1도 차이는 위도에 따라 다름\n        double latDiff = radiusInKm / 111.0;\n        double lonDiff = radiusInKm / (111.0 * Math.cos(Math.toRadians(latitude)));\n        \n        double minLat = latitude - latDiff;\n        double maxLat = latitude + latDiff;\n        double minLon = longitude - lonDiff;\n        double maxLon = longitude + lonDiff;\n        \n        // 대략적인 범위 내 대피소 조회 (DB 쿼리 최적화)\n        List<Shelter> candidateShelters = shelterRepository.findByLatitudeBetweenAndLongitudeBetween(\n                minLat, maxLat, minLon, maxLon);\n        \n        // 정확한 거리 계산 및 필터링\n        return candidateShelters.stream()\n                .filter(shelter -> calculateDistance(latitude, longitude, \n                        shelter.getLatitude(), shelter.getLongitude()) <= radiusInKm * 1000)\n                .collect(Collectors.toList());\n    }\n    \n    // 가장 가까운 N개 대피소 찾기\n    public List<ShelterDto> findNearestShelters(double latitude, double longitude, int limit) {\n        // 먼저 넓은 반경에서 후보 대피소 검색 (예: 10km)\n        List<Shelter> nearbyShelters = findNearbyShelters(latitude, longitude, 10.0);\n        \n        // 거리 계산 및 정렬\n        return nearbyShelters.stream()\n                .map(shelter -> {\n                    double distance = calculateDistance(latitude, longitude, \n                            shelter.getLatitude(), shelter.getLongitude());\n                    \n                    return ShelterDto.builder()\n                            .id(shelter.getId())\n                            .name(shelter.getName())\n                            .address(shelter.getAddress())\n                            .latitude(shelter.getLatitude())\n                            .longitude(shelter.getLongitude())\n                            .capacity(shelter.getCapacity())\n                            .type(shelter.getType())\n                            .contact(shelter.getContact())\n                            .distance(distance)\n                            .build();\n                })\n                .sorted(Comparator.comparing(ShelterDto::getDistance))\n                .limit(limit)\n                .collect(Collectors.toList());\n    }\n    \n    // 하버사인 공식을 사용한 두 좌표 간 거리 계산 (미터 단위)\n    public double calculateDistance(double lat1, double lon1, double lat2, double lon2) {\n        double latDistance = Math.toRadians(lat2 - lat1);\n        double lonDistance = Math.toRadians(lon2 - lon1);\n        \n        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)\n                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))\n                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);\n        \n        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n        \n        return EARTH_RADIUS * c * 1000; // 미터 단위로 변환\n    }\n}\n```\n\n2. Repository 인터페이스 확장:\n```java\npublic interface ShelterRepository extends JpaRepository<Shelter, Long> {\n    List<Shelter> findByLatitudeBetweenAndLongitudeBetween(\n            double minLatitude, double maxLatitude, \n            double minLongitude, double maxLongitude);\n}\n```\n\n3. 서비스 계층 업데이트:\n```java\n@Service\n@RequiredArgsConstructor\npublic class ShelterService {\n    private final ShelterRepository shelterRepository;\n    private final AddressService addressService;\n    private final DistanceCalculationService distanceService;\n    \n    // 기존 메소드들...\n    \n    public List<ShelterDto> findNearestShelters(Double latitude, Double longitude, int limit) {\n        return distanceService.findNearestShelters(latitude, longitude, limit);\n    }\n    \n    public List<ShelterDto> findSheltersByAddress(String address) {\n        // 주소를 좌표로 변환\n        Coordinates coords = addressService.getCoordinatesByAddress(address);\n        if (coords != null) {\n            return findNearestShelters(coords.getLatitude(), coords.getLongitude(), 10);\n        }\n        return Collections.emptyList();\n    }\n}\n```",
        "testStrategy": "1. 거리 계산 알고리즘 정확성 테스트\n2. 다양한 좌표 쌍에 대한 거리 계산 테스트\n3. 대량의 대피소 데이터에 대한 성능 테스트\n4. 경계 케이스 테스트 (예: 위도/경도 범위 경계)\n5. 정렬 결과 정확성 테스트",
        "priority": "medium",
        "dependencies": [
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "대피소 상세 정보 표시 기능 구현",
        "description": "선택된 대피소의 상세 정보를 표시하는 UI 컴포넌트 구현",
        "details": "1. 대피소 상세 정보 컴포넌트 구현:\n```tsx\nimport React from 'react';\nimport styled from 'styled-components';\n\ninterface Shelter {\n  id: number;\n  name: string;\n  address: string;\n  latitude: number;\n  longitude: number;\n  capacity: number;\n  type: string;\n  contact: string;\n  distance: number;\n}\n\ninterface ShelterDetailProps {\n  shelter: Shelter | null;\n  onClose: () => void;\n}\n\nconst DetailContainer = styled.div`\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  background: white;\n  padding: 20px;\n  border-radius: 15px 15px 0 0;\n  box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);\n  z-index: 1000;\n  transform: translateY(${props => props.show ? '0' : '100%'});\n  transition: transform 0.3s ease-in-out;\n  max-height: 50vh;\n  overflow-y: auto;\n`;\n\nconst CloseButton = styled.button`\n  position: absolute;\n  top: 15px;\n  right: 15px;\n  background: none;\n  border: none;\n  font-size: 20px;\n  cursor: pointer;\n  color: #666;\n`;\n\nconst DetailTitle = styled.h2`\n  margin-top: 0;\n  margin-bottom: 15px;\n  color: #333;\n  font-size: 20px;\n`;\n\nconst DetailItem = styled.div`\n  margin-bottom: 10px;\n`;\n\nconst Label = styled.span`\n  font-weight: bold;\n  color: #555;\n  margin-right: 5px;\n`;\n\nconst Value = styled.span`\n  color: #333;\n`;\n\nconst DirectionsButton = styled.button`\n  background: #4285f4;\n  color: white;\n  border: none;\n  padding: 10px 15px;\n  border-radius: 4px;\n  margin-top: 15px;\n  cursor: pointer;\n  font-weight: bold;\n  &:hover {\n    background: #3367d6;\n  }\n`;\n\nconst ShelterDetail: React.FC<ShelterDetailProps> = ({ shelter, onClose }) => {\n  if (!shelter) return null;\n  \n  const openDirections = () => {\n    // 카카오맵 길찾기 URL 생성\n    const url = `https://map.kakao.com/link/to/${shelter.name},${shelter.latitude},${shelter.longitude}`;\n    window.open(url, '_blank');\n  };\n  \n  return (\n    <DetailContainer show={!!shelter}>\n      <CloseButton onClick={onClose}>×</CloseButton>\n      <DetailTitle>{shelter.name}</DetailTitle>\n      \n      <DetailItem>\n        <Label>주소:</Label>\n        <Value>{shelter.address}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>유형:</Label>\n        <Value>{shelter.type}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>수용 인원:</Label>\n        <Value>{shelter.capacity}명</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>연락처:</Label>\n        <Value>{shelter.contact || '정보 없음'}</Value>\n      </DetailItem>\n      \n      <DetailItem>\n        <Label>거리:</Label>\n        <Value>{(shelter.distance / 1000).toFixed(2)}km</Value>\n      </DetailItem>\n      \n      <DirectionsButton onClick={openDirections}>\n        길찾기\n      </DirectionsButton>\n    </DetailContainer>\n  );\n};\n\nexport default ShelterDetail;\n```\n\n2. MapComponent 업데이트하여 상세 정보 컴포넌트 통합:\n```tsx\nimport React, { useState, useEffect } from 'react';\nimport { Map, MapMarker } from 'react-kakao-maps-sdk';\nimport axios from 'axios';\nimport ShelterDetail from './ShelterDetail';\nimport api from '../services/api';\n\n// 인터페이스 정의 생략 (이전과 동일)\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  const [center, setCenter] = useState({\n    lat: 37.5666805,\n    lng: 126.9784147,\n  });\n  const [shelters, setShelters] = useState<Shelter[]>([]);\n  const [selectedShelter, setSelectedShelter] = useState<Shelter | null>(null);\n  \n  useEffect(() => {\n    if (searchAddress) {\n      // 주소로 대피소 검색\n      api.get(`/api/shelters/search?address=${encodeURIComponent(searchAddress)}`)\n        .then(response => {\n          setShelters(response.data);\n          \n          if (response.data.length > 0) {\n            // 첫 번째 대피소 위치로 지도 중심 이동\n            setCenter({\n              lat: response.data[0].latitude,\n              lng: response.data[0].longitude\n            });\n          }\n        })\n        .catch(error => {\n          console.error('Error fetching shelters:', error);\n        });\n    }\n  }, [searchAddress]);\n  \n  const handleMarkerClick = (shelter: Shelter) => {\n    setSelectedShelter(shelter);\n  };\n  \n  const handleCloseDetail = () => {\n    setSelectedShelter(null);\n  };\n  \n  return (\n    <div className=\"map-container\">\n      <Map\n        center={center}\n        style={{ width: '100%', height: '500px' }}\n        level={3}\n      >\n        {shelters.map(shelter => (\n          <MapMarker\n            key={shelter.id}\n            position={{ lat: shelter.latitude, lng: shelter.longitude }}\n            onClick={() => handleMarkerClick(shelter)}\n            image={{\n              src: '/marker.png',\n              size: { width: 24, height: 35 },\n            }}\n          />\n        ))}\n      </Map>\n      \n      <ShelterDetail \n        shelter={selectedShelter} \n        onClose={handleCloseDetail} \n      />\n    </div>\n  );\n};\n\nexport default MapComponent;\n```",
        "testStrategy": "1. 대피소 상세 정보 표시 기능 테스트\n2. 모달 열기/닫기 기능 테스트\n3. 길찾기 버튼 기능 테스트\n4. 다양한 화면 크기에서의 UI 테스트\n5. 누락된 정보 처리 테스트 (예: 연락처 없음)",
        "priority": "medium",
        "dependencies": [
          8
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "반응형 디자인 적용",
        "description": "모바일 및 데스크톱 환경에 모두 대응하는 반응형 UI 구현",
        "details": "1. 반응형 스타일 컴포넌트 설정:\n```tsx\n// src/styles/responsive.ts\nimport { css } from 'styled-components';\n\nexport const breakpoints = {\n  mobile: 576,\n  tablet: 768,\n  desktop: 992,\n};\n\nexport const media = {\n  mobile: (...args) => css`\n    @media (max-width: ${breakpoints.mobile}px) {\n      ${css(...args)};\n    }\n  `,\n  tablet: (...args) => css`\n    @media (min-width: ${breakpoints.mobile + 1}px) and (max-width: ${breakpoints.tablet}px) {\n      ${css(...args)};\n    }\n  `,\n  desktop: (...args) => css`\n    @media (min-width: ${breakpoints.tablet + 1}px) {\n      ${css(...args)};\n    }\n  `,\n};\n```\n\n2. 반응형 레이아웃 컴포넌트 구현:\n```tsx\n// src/components/Layout.tsx\nimport React from 'react';\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\nconst Container = styled.div`\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 0 20px;\n  \n  ${media.mobile`\n    padding: 0 10px;\n  `}\n`;\n\nconst Header = styled.header`\n  padding: 20px 0;\n  text-align: center;\n  \n  ${media.mobile`\n    padding: 15px 0;\n  `}\n`;\n\nconst Title = styled.h1`\n  font-size: 28px;\n  color: #333;\n  margin: 0;\n  \n  ${media.mobile`\n    font-size: 22px;\n  `}\n`;\n\nconst Main = styled.main`\n  min-height: calc(100vh - 120px);\n`;\n\nconst Footer = styled.footer`\n  padding: 20px 0;\n  text-align: center;\n  color: #666;\n  font-size: 14px;\n  \n  ${media.mobile`\n    padding: 15px 0;\n    font-size: 12px;\n  `}\n`;\n\ninterface LayoutProps {\n  children: React.ReactNode;\n}\n\nconst Layout: React.FC<LayoutProps> = ({ children }) => {\n  return (\n    <Container>\n      <Header>\n        <Title>대피소 찾기 서비스</Title>\n      </Header>\n      <Main>{children}</Main>\n      <Footer>\n        &copy; {new Date().getFullYear()} SafetyFirst. All rights reserved.\n      </Footer>\n    </Container>\n  );\n};\n\nexport default Layout;\n```\n\n3. 반응형 지도 컴포넌트 업데이트:\n```tsx\n// MapComponent.tsx 업데이트\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\n// 기존 코드...\n\nconst MapContainer = styled.div`\n  width: 100%;\n  height: 600px;\n  margin-bottom: 20px;\n  \n  ${media.mobile`\n    height: 400px;\n    margin-bottom: 10px;\n  `}\n`;\n\nconst MapComponent: React.FC<MapComponentProps> = ({ searchAddress }) => {\n  // 기존 코드...\n  \n  return (\n    <MapContainer>\n      <Map\n        center={center}\n        style={{ width: '100%', height: '100%' }}\n        level={3}\n      >\n        {/* 마커 코드... */}\n      </Map>\n      \n      <ShelterDetail \n        shelter={selectedShelter} \n        onClose={handleCloseDetail} \n      />\n    </MapContainer>\n  );\n};\n```\n\n4. 반응형 검색 컴포넌트 업데이트:\n```tsx\n// AddressSearch.tsx 업데이트\nimport styled from 'styled-components';\nimport { media } from '../styles/responsive';\n\n// 기존 코드...\n\nconst SearchContainer = styled.div`\n  width: 100%;\n  max-width: 500px;\n  margin: 20px auto;\n  position: relative;\n  \n  ${media.mobile`\n    max-width: 100%;\n    margin: 10px auto;\n  `}\n`;\n\nconst SearchInput = styled.input`\n  width: 100%;\n  padding: 12px 15px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);\n  \n  ${media.mobile`\n    padding: 10px;\n    font-size: 14px;\n  `}\n  \n  &:focus {\n    outline: none;\n    border-color: #4285f4;\n  }\n`;\n\n// 나머지 코드...\n```\n\n5. App.tsx에 레이아웃 적용:\n```tsx\nimport React, { useState } from 'react';\nimport './App.css';\nimport MapComponent from './components/MapComponent';\nimport AddressSearch from './components/AddressSearch';\nimport Layout from './components/Layout';\n\nfunction App() {\n  const [searchAddress, setSearchAddress] = useState('');\n  \n  const handleSearch = (address: string) => {\n    setSearchAddress(address);\n  };\n  \n  return (\n    <Layout>\n      <AddressSearch onSearch={handleSearch} />\n      <MapComponent searchAddress={searchAddress} />\n    </Layout>\n  );\n}\n\nexport default App;\n```\n\n6. 글로벌 스타일 추가 (src/styles/GlobalStyle.ts):\n```tsx\nimport { createGlobalStyle } from 'styled-components';\n\nconst GlobalStyle = createGlobalStyle`\n  * {\n    box-sizing: border-box;\n  }\n  \n  body {\n    margin: 0;\n    padding: 0;\n    font-family: 'Noto Sans KR', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\n      'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n    -webkit-font-smoothing: antialiased;\n    -moz-osx-font-smoothing: grayscale;\n    background-color: #f9f9f9;\n  }\n`;\n\nexport default GlobalStyle;\n```\n\n7. index.tsx에 글로벌 스타일 적용:\n```tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport GlobalStyle from './styles/GlobalStyle';\n\nReactDOM.render(\n  <React.StrictMode>\n    <GlobalStyle />\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n```",
        "testStrategy": "1. 다양한 화면 크기에서의 레이아웃 테스트 (모바일, 태블릿, 데스크톱)\n2. 브라우저 호환성 테스트 (Chrome, Firefox, Safari, Edge)\n3. 반응형 요소들의 동작 확인\n4. 모바일 터치 인터랙션 테스트\n5. 다양한 기기에서의 사용성 테스트",
        "priority": "low",
        "dependencies": [
          5,
          8,
          10
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "코드 최적화 및 문서화",
        "description": "코드 리팩토링, 주석 추가, 문서화 및 최종 테스트",
        "details": "1. 코드 리팩토링:\n   - 중복 코드 제거\n   - 컴포넌트 분리 및 재사용성 향상\n   - 성능 최적화 (불필요한 렌더링 방지)\n   - 타입 정의 개선\n\n2. 주석 추가:\n   - 각 컴포넌트 및 함수에 JSDoc 형식의 주석 추가\n   - 복잡한 로직에 대한 설명 추가\n   - 예시:\n   ```typescript\n   /**\n    * 두 지리적 좌표 사이의 거리를 계산합니다.\n    * @param lat1 - 첫 번째 위치의 위도\n    * @param lon1 - 첫 번째 위치의 경도\n    * @param lat2 - 두 번째 위치의 위도\n    * @param lon2 - 두 번째 위치의 경도\n    * @returns 두 위치 사이의 거리 (미터 단위)\n    */\n   function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {\n     // 구현...\n   }\n   ```\n\n3. 에러 처리 개선:\n   - 사용자 친화적인 에러 메시지 표시\n   - 에러 발생 시 대체 UI 제공\n   - 예시:\n   ```typescript\n   const ErrorMessage = styled.div`\n     color: #d32f2f;\n     background-color: #ffebee;\n     padding: 10px;\n     border-radius: 4px;\n     margin: 10px 0;\n     text-align: center;\n   `;\n   \n   // 컴포넌트 내부\n   const [error, setError] = useState<string | null>(null);\n   \n   // API 호출 부분\n   api.get('/api/shelters/search')\n     .then(response => {\n       // 성공 처리\n     })\n     .catch(err => {\n       console.error('API 호출 실패:', err);\n       setError('대피소 정보를 불러오는데 실패했습니다. 잠시 후 다시 시도해주세요.');\n     });\n   \n   // 렌더링 부분\n   {error && <ErrorMessage>{error}</ErrorMessage>}\n   ```\n\n4. 로딩 상태 처리:\n   - 데이터 로딩 중 스켈레톤 UI 또는 로딩 인디케이터 표시\n   - 예시:\n   ```typescript\n   const LoadingSpinner = styled.div`\n     display: flex;\n     justify-content: center;\n     align-items: center;\n     height: 200px;\n   `;\n   \n   // 컴포넌트 내부\n   const [loading, setLoading] = useState(false);\n   \n   // API 호출 부분\n   setLoading(true);\n   api.get('/api/shelters/search')\n     .then(response => {\n       // 성공 처리\n     })\n     .catch(err => {\n       // 에러 처리\n     })\n     .finally(() => {\n       setLoading(false);\n     });\n   \n   // 렌더링 부분\n   {loading ? (\n     <LoadingSpinner>\n       <div className=\"spinner\"></div>\n     </LoadingSpinner>\n   ) : (\n     // 실제 컨텐츠\n   )}\n   ```\n\n5. README.md 작성:\n   - 프로젝트 개요\n   - 설치 방법\n   - 실행 방법\n   - API 문서\n   - 폴더 구조 설명\n   - 기술 스택 소개\n   - 기여 방법\n\n6. API 문서화:\n   - Swagger 또는 Spring REST Docs를 사용한 API 문서화\n   - 예시 (Swagger 설정):\n   ```java\n   @Configuration\n   @EnableSwagger2\n   public class SwaggerConfig {\n       @Bean\n       public Docket api() {\n           return new Docket(DocumentationType.SWAGGER_2)\n                   .select()\n                   .apis(RequestHandlerSelectors.basePackage(\"com.safetyfirst.controller\"))\n                   .paths(PathSelectors.any())\n                   .build()\n                   .apiInfo(apiInfo());\n       }\n       \n       private ApiInfo apiInfo() {\n           return new ApiInfoBuilder()\n                   .title(\"SafetyFirst API\")\n                   .description(\"대피소 찾기 서비스 API 문서\")\n                   .version(\"1.0.0\")\n                   .build();\n       }\n   }\n   ```\n\n7. 최종 테스트:\n   - 모든 기능에 대한 종합 테스트\n   - 크로스 브라우저 테스트\n   - 성능 테스트\n   - 사용성 테스트",
        "testStrategy": "1. 코드 품질 검사 도구 실행 (ESLint, SonarQube 등)\n2. 단위 테스트 및 통합 테스트 실행\n3. 성능 테스트 (로딩 시간, 메모리 사용량 등)\n4. 크로스 브라우저 테스트\n5. 코드 리뷰 진행\n6. 문서 정확성 검증",
        "priority": "low",
        "dependencies": [
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-01T08:01:08.699Z",
      "updated": "2025-07-03T07:38:43.468Z",
      "description": "프론트엔드 개발 작업 (TypeScript + React, 카카오 맵 API)"
    }
  }
}